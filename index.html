<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Blitz Arena - Rapid Improvement Trainer</title>

    <!-- Chess.js for move validation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <!-- Stockfish for AI analysis -->
    <script src="https://cdn.jsdelivr.net/npm/stockfish@latest/src/stockfish.js"></script>

    <!-- Session Tracker - Records all user interactions, errors, performance -->
    <script src="session-tracker.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;600;700;800&display=swap');

        :root {
            --primary: #6c5ce7;
            --secondary: #00cec9;
            --accent: #fd79a8;
            --gold: #fdcb6e;
            --fire: #e17055;
            --success: #00b894;
            --dark: #2d3436;
            --light: #dfe6e9;
            --xp-bar: linear-gradient(90deg, #6c5ce7, #a29bfe);
            --streak-fire: linear-gradient(135deg, #ff7675, #fd79a8);
            --legendary: linear-gradient(135deg, #fdcb6e, #f39c12, #e74c3c);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        /* Floating particles background */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 0;
        }

        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(108, 92, 231, 0.3);
            border-radius: 50%;
            animation: float 15s infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100vh) rotate(720deg); opacity: 0; }
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 100;
            border-bottom: 2px solid rgba(108, 92, 231, 0.3);
        }

        .logo {
            font-family: 'Fredoka One', cursive;
            font-size: 28px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(108, 92, 231, 0.5);
        }

        .logo span {
            color: var(--gold);
            -webkit-text-fill-color: var(--gold);
        }

        /* Profile Selector */
        .profile-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 25px;
        }

        .profile-selector select {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 1px solid rgba(108, 92, 231, 0.5);
            border-radius: 12px;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            outline: none;
            transition: all 0.3s;
        }

        .profile-selector select:hover {
            border-color: var(--primary);
            background: rgba(108, 92, 231, 0.2);
        }

        .profile-selector select option {
            background: var(--dark);
            color: white;
        }

        .profile-btn {
            background: rgba(108, 92, 231, 0.3);
            border: none;
            color: white;
            font-size: 16px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .profile-btn:hover {
            background: var(--primary);
            transform: rotate(90deg);
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 25px;
            font-weight: 700;
        }

        .stat-icon {
            font-size: 20px;
        }

        .coins {
            color: var(--gold);
        }

        .rating {
            color: var(--secondary);
        }

        /* Level Progress */
        .level-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .level-badge {
            width: 45px;
            height: 45px;
            background: var(--xp-bar);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            border: 3px solid var(--gold);
            box-shadow: 0 0 15px rgba(253, 203, 110, 0.5);
        }

        .xp-bar-container {
            width: 150px;
        }

        .xp-bar-bg {
            height: 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
        }

        .xp-bar-fill {
            height: 100%;
            background: var(--xp-bar);
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(108, 92, 231, 0.5);
        }

        .xp-text {
            font-size: 11px;
            color: var(--light);
            margin-top: 2px;
        }

        /* Main Container */
        .main-container {
            display: flex;
            gap: 30px;
            padding: 30px;
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
        }

        /* Left Panel - Powers & Inventory */
        .left-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-title {
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Power-ups */
        .powers-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .power-btn {
            background: linear-gradient(135deg, rgba(108, 92, 231, 0.3), rgba(162, 155, 254, 0.2));
            border: 2px solid rgba(108, 92, 231, 0.5);
            border-radius: 15px;
            padding: 15px 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .power-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(108, 92, 231, 0.4);
            border-color: var(--primary);
        }

        .power-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .power-icon {
            font-size: 28px;
        }

        .power-name {
            font-size: 11px;
            font-weight: 700;
            color: var(--light);
        }

        .power-count {
            font-size: 10px;
            color: var(--gold);
        }

        /* Gloves/Themes */
        .gloves-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .glove-item {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            position: relative;
        }

        .glove-item.active {
            border-color: var(--gold);
            box-shadow: 0 0 15px rgba(253, 203, 110, 0.5);
        }

        .glove-item.locked {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .glove-item.locked::after {
            content: 'üîí';
            position: absolute;
            font-size: 14px;
        }

        .glove-item:hover:not(.locked) {
            transform: scale(1.1);
        }

        /* Center - Chess Board */
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        /* Streak Display */
        .streak-container {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50px;
            border: 2px solid transparent;
        }

        .streak-container.on-fire {
            border-color: var(--fire);
            box-shadow: 0 0 30px rgba(225, 112, 85, 0.5);
            animation: pulse-fire 1s infinite;
        }

        @keyframes pulse-fire {
            0%, 100% { box-shadow: 0 0 30px rgba(225, 112, 85, 0.5); }
            50% { box-shadow: 0 0 50px rgba(225, 112, 85, 0.8); }
        }

        .streak-flames {
            font-size: 32px;
            animation: flame-dance 0.5s infinite alternate;
        }

        @keyframes flame-dance {
            from { transform: scale(1) rotate(-5deg); }
            to { transform: scale(1.1) rotate(5deg); }
        }

        .streak-count {
            font-family: 'Fredoka One', cursive;
            font-size: 36px;
            color: var(--fire);
            text-shadow: 0 0 20px rgba(225, 112, 85, 0.5);
        }

        .streak-label {
            font-size: 14px;
            color: var(--light);
        }

        .streak-bonus {
            background: var(--streak-fire);
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 14px;
        }

        /* Chess Board */
        .board-container {
            position: relative;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 4px solid var(--primary);
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 42px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        /* White pieces - light colored with dark shadow */
        .square.white-piece {
            color: #ffffff;
            text-shadow:
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 0 8px rgba(255, 255, 255, 0.8);
            font-weight: bold;
        }

        /* Black pieces - dark colored with light shadow */
        .square.black-piece {
            color: #1a1a1a;
            text-shadow:
                -1px -1px 0 #fff,
                1px -1px 0 #fff,
                -1px 1px 0 #fff,
                1px 1px 0 #fff,
                0 0 8px rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }

        .square.selected {
            box-shadow: inset 0 0 0 4px var(--primary), 0 0 10px var(--primary);
            background-color: rgba(108, 92, 231, 0.3) !important;
        }

        .square.hint {
            position: relative;
        }

        .square.hint::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(108, 92, 231, 0.5);
            border-radius: 50%;
        }

        .square.correct {
            animation: correct-flash 0.5s ease;
        }

        @keyframes correct-flash {
            0%, 100% { background: inherit; }
            50% { background: var(--success); }
        }

        .square.wrong {
            animation: wrong-shake 0.5s ease;
        }

        @keyframes wrong-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); background: var(--fire); }
            75% { transform: translateX(5px); background: var(--fire); }
        }

        .square.illegal {
            animation: illegal-shake 0.5s ease;
        }

        @keyframes illegal-shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); background: #ff6b6b; }
            20%, 40%, 60%, 80% { transform: translateX(3px); background: #ff6b6b; }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
        }

        .square.legal-move {
            position: relative;
        }

        .square.legal-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30%;
            height: 30%;
            background: rgba(108, 92, 231, 0.6);
            border-radius: 50%;
            pointer-events: none;
        }

        .square.legal-move.has-piece::after {
            width: 80%;
            height: 80%;
            background: transparent;
            border: 4px solid rgba(108, 92, 231, 0.6);
            border-radius: 50%;
        }

        /* Theme variations */
        .board-container.theme-neon .square.light { background: #1a1a2e; }
        .board-container.theme-neon .square.dark { background: #0f0f1a; }
        .board-container.theme-neon .square { color: #00ff88; text-shadow: 0 0 10px #00ff88; }

        .board-container.theme-ice .square.light { background: #e8f4fc; }
        .board-container.theme-ice .square.dark { background: #a8d4e6; }

        .board-container.theme-fire .square.light { background: #ffeaa7; }
        .board-container.theme-fire .square.dark { background: #e17055; }

        .board-container.theme-royal .square.light { background: #dfe6e9; }
        .board-container.theme-royal .square.dark { background: #6c5ce7; }

        /* Puzzle Info */
        .puzzle-info {
            text-align: center;
            max-width: 500px;
        }

        .puzzle-title {
            font-family: 'Fredoka One', cursive;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .puzzle-instruction {
            color: var(--light);
            font-size: 16px;
        }

        .puzzle-instruction .highlight {
            color: var(--secondary);
            font-weight: 700;
        }

        /* Puzzle Navigation */
        .puzzle-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            max-width: 500px;
        }

        .nav-btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s;
        }

        .nav-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.4);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        .puzzle-position {
            color: var(--light);
            font-family: 'Fredoka One', cursive;
            font-size: 16px;
            min-width: 120px;
            text-align: center;
        }

        /* Timer */
        .timer-container {
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: 'Fredoka One', cursive;
            font-size: 28px;
        }

        .timer-icon {
            font-size: 24px;
        }

        .timer.warning {
            color: var(--fire);
            animation: timer-pulse 0.5s infinite;
        }

        @keyframes timer-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Right Panel - Progress & Achievements */
        .right-panel {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Daily Challenge */
        .daily-challenge {
            background: linear-gradient(135deg, rgba(253, 203, 110, 0.2), rgba(243, 156, 18, 0.1));
            border: 2px solid var(--gold);
        }

        .daily-progress {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .daily-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .daily-dot.complete {
            background: var(--success);
        }

        .daily-reward {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            text-align: center;
        }

        /* Ranking Progress */
        .rank-display {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .rank-icon {
            width: 60px;
            height: 60px;
            background: var(--legendary);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            box-shadow: 0 5px 20px rgba(253, 203, 110, 0.4);
        }

        .rank-info {
            flex: 1;
        }

        .rank-name {
            font-family: 'Fredoka One', cursive;
            font-size: 20px;
            color: var(--gold);
        }

        .rank-rating {
            color: var(--light);
            font-size: 14px;
        }

        .rank-progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 15px;
        }

        .rank-progress-fill {
            height: 100%;
            background: var(--legendary);
            transition: width 0.5s ease;
        }

        .rank-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--light);
            margin-top: 5px;
        }

        /* Achievements */
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .achievement {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .achievement.unlocked {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.4);
        }

        .achievement.locked {
            opacity: 0.3;
            filter: grayscale(1);
        }

        .achievement:hover {
            transform: scale(1.1);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 30px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            border: 3px solid var(--primary);
            box-shadow: 0 30px 100px rgba(108, 92, 231, 0.5);
            animation: modal-pop 0.3s ease;
        }

        @keyframes modal-pop {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-title {
            font-family: 'Fredoka One', cursive;
            font-size: 32px;
            margin-bottom: 20px;
        }

        .modal-emoji {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .btn {
            background: var(--xp-bar);
            border: none;
            padding: 15px 40px;
            border-radius: 30px;
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(108, 92, 231, 0.5);
        }

        .btn-gold {
            background: var(--legendary);
            color: #1a1a2e;
        }

        /* Assessment Progress */
        .assessment-progress {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .assessment-dot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            transition: all 0.3s ease;
        }

        .assessment-dot.current {
            background: var(--primary);
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(108, 92, 231, 0.5);
        }

        /* Profile Management Modal */
        #profile-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #profile-modal .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid var(--primary);
            box-shadow: 0 30px 100px rgba(108, 92, 231, 0.5);
        }

        #profile-modal h2 {
            color: var(--gold);
            margin-bottom: 25px;
            font-size: 28px;
        }

        .profile-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .profile-section h3 {
            color: var(--secondary);
            margin-bottom: 15px;
            font-size: 18px;
        }

        .profile-section input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(108, 92, 231, 0.5);
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .profile-section input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(108, 92, 231, 0.1);
        }

        .profile-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(108, 92, 231, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .profile-item.active {
            border-color: var(--gold);
            background: rgba(253, 203, 110, 0.1);
        }

        .profile-item.archived {
            opacity: 0.6;
            border-color: rgba(255, 255, 255, 0.2);
        }

        .profile-info {
            flex: 1;
        }

        .profile-name {
            font-weight: 700;
            font-size: 16px;
            color: white;
            margin-bottom: 4px;
        }

        .profile-meta {
            font-size: 12px;
            color: var(--light);
            opacity: 0.7;
        }

        .profile-actions {
            display: flex;
            gap: 8px;
        }

        .profile-actions button {
            background: rgba(108, 92, 231, 0.3);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .profile-actions button:hover {
            background: var(--primary);
        }

        .profile-actions button.danger {
            background: rgba(255, 0, 0, 0.3);
        }

        .profile-actions button.danger:hover {
            background: rgba(255, 0, 0, 0.6);
        }

        .btn-primary, .btn-secondary {
            background: var(--primary);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn-primary:hover, .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(108, 92, 231, 0.4);
        }

        .btn-secondary {
            background: rgba(108, 92, 231, 0.5);
        }

        .close-modal {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: all 0.2s;
        }

        .close-modal:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .assessment-dot.correct {
            background: var(--success);
        }

        .assessment-dot.wrong {
            background: var(--fire);
        }

        /* Confetti */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confetti-fall 3s linear forwards;
        }

        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* XP Popup */
        .xp-popup {
            position: fixed;
            font-family: 'Fredoka One', cursive;
            font-size: 24px;
            color: var(--gold);
            pointer-events: none;
            animation: xp-float 1.5s ease-out forwards;
            z-index: 100;
            text-shadow: 0 0 10px rgba(253, 203, 110, 0.8);
        }

        @keyframes xp-float {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-100px) scale(1.5); opacity: 0; }
        }

        /* Level Up Animation */
        .level-up-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .level-up-overlay.active {
            display: flex;
            animation: level-up-bg 2s ease;
        }

        @keyframes level-up-bg {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        .level-up-content {
            text-align: center;
            animation: level-up-pop 2s ease;
        }

        @keyframes level-up-pop {
            0% { transform: scale(0); }
            20% { transform: scale(1.2); }
            40% { transform: scale(1); }
            100% { transform: scale(1); opacity: 0; }
        }

        .level-up-text {
            font-family: 'Fredoka One', cursive;
            font-size: 60px;
            background: var(--legendary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
        }

        .level-up-number {
            font-family: 'Fredoka One', cursive;
            font-size: 120px;
            color: var(--gold);
            text-shadow: 0 0 50px rgba(253, 203, 110, 0.8);
        }

        /* Coaching Toast */
        .coaching-toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 400px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid var(--gold);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            display: flex;
            gap: 15px;
            align-items: flex-start;
            z-index: 10000;
            animation: slideInRight 0.5s ease;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(500px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .coach-avatar {
            font-size: 48px;
            line-height: 1;
        }

        .coach-message {
            flex: 1;
        }

        .coach-title {
            font-weight: bold;
            color: var(--gold);
            font-size: 16px;
            margin-bottom: 8px;
        }

        .coach-text {
            color: white;
            line-height: 1.6;
            font-size: 14px;
        }

        .coach-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .coach-close:hover {
            opacity: 1;
        }

        /* Shop Button */
        .shop-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: var(--legendary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(253, 203, 110, 0.5);
            transition: all 0.3s ease;
            z-index: 100;
            border: none;
        }

        .shop-btn:hover {
            transform: scale(1.1) rotate(10deg);
        }

        /* Rating Change Display */
        .rating-change {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Fredoka One', cursive;
            font-size: 48px;
            pointer-events: none;
            animation: rating-pop 1.5s ease-out forwards;
            z-index: 500;
        }

        .rating-change.positive {
            color: var(--success);
        }

        .rating-change.negative {
            color: var(--fire);
        }

        @keyframes rating-pop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.5); }
            100% { transform: translate(-50%, -100%) scale(1); opacity: 0; }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .left-panel, .right-panel {
                width: 100%;
                max-width: 500px;
            }
        }
    </style>
</head>
<body>
    <!-- Floating Particles -->
    <div class="particles" id="particles"></div>

    <!-- Header -->
    <header class="header">
        <div class="logo">Chess<span>Blitz</span>Arena</div>

        <!-- Profile Selector -->
        <div class="profile-selector">
            <span class="stat-icon">üë§</span>
            <select id="profile-dropdown" onchange="switchProfile(this.value)">
                <!-- Populated by JS -->
            </select>
            <button class="profile-btn" onclick="showProfileManagement()">‚öôÔ∏è</button>
        </div>

        <div class="stats-bar">
            <div class="stat-item coins">
                <span class="stat-icon">üí∞</span>
                <span id="coins-display">500</span>
            </div>
            <div class="stat-item rating">
                <span class="stat-icon">‚ö°</span>
                <span id="rating-display">800</span>
            </div>
            <div class="level-container">
                <div class="level-badge" id="level-badge">1</div>
                <div class="xp-bar-container">
                    <div class="xp-bar-bg">
                        <div class="xp-bar-fill" id="xp-bar" style="width: 0%"></div>
                    </div>
                    <div class="xp-text"><span id="xp-current">0</span> / <span id="xp-needed">100</span> XP</div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Panel -->
        <div class="left-panel">
            <!-- Power-ups -->
            <div class="panel">
                <div class="panel-title">‚ö° Power-Ups</div>
                <div class="powers-grid">
                    <button class="power-btn" id="power-hint" onclick="usePower('hint')">
                        <span class="power-icon">üí°</span>
                        <span class="power-name">HINT</span>
                        <span class="power-count" id="hint-count">3</span>
                    </button>
                    <button class="power-btn" id="power-freeze" onclick="usePower('freeze')">
                        <span class="power-icon">‚ùÑÔ∏è</span>
                        <span class="power-name">FREEZE</span>
                        <span class="power-count" id="freeze-count">2</span>
                    </button>
                    <button class="power-btn" id="power-skip" onclick="usePower('skip')">
                        <span class="power-icon">‚è≠Ô∏è</span>
                        <span class="power-name">SKIP</span>
                        <span class="power-count" id="skip-count">1</span>
                    </button>
                    <button class="power-btn" id="power-double" onclick="usePower('double')">
                        <span class="power-icon">‚ú®</span>
                        <span class="power-name">2X XP</span>
                        <span class="power-count" id="double-count">1</span>
                    </button>
                </div>
            </div>

            <!-- Board Themes (Gloves) -->
            <div class="panel">
                <div class="panel-title">üé® Board Skins</div>
                <div class="gloves-grid">
                    <div class="glove-item active" data-theme="classic" onclick="selectTheme('classic')">‚ôüÔ∏è</div>
                    <div class="glove-item" data-theme="neon" onclick="selectTheme('neon')">üíö</div>
                    <div class="glove-item" data-theme="ice" onclick="selectTheme('ice')">üßä</div>
                    <div class="glove-item" data-theme="fire" onclick="selectTheme('fire')">üî•</div>
                    <div class="glove-item" data-theme="royal" onclick="selectTheme('royal')">üëë</div>
                    <div class="glove-item locked" data-theme="galaxy">üåå</div>
                    <div class="glove-item locked" data-theme="diamond">üíé</div>
                    <div class="glove-item locked" data-theme="rainbow">üåà</div>
                    <div class="glove-item locked" data-theme="legendary">‚≠ê</div>
                </div>
            </div>

            <!-- Stats -->
            <div class="panel">
                <div class="panel-title">üìä Session Stats</div>
                <div style="display: grid; gap: 10px;">
                    <div style="display: flex; justify-content: space-between;">
                        <span>Puzzles Solved</span>
                        <span id="puzzles-solved">0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>Accuracy</span>
                        <span id="accuracy">0%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>Best Streak</span>
                        <span id="best-streak">0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>Rating Gained</span>
                        <span id="rating-gained" style="color: var(--success);">+0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Center Panel -->
        <div class="center-panel">
            <!-- Streak Display -->
            <div class="streak-container" id="streak-container">
                <span class="streak-flames" id="streak-flames">üî•</span>
                <div>
                    <div class="streak-count" id="streak-count">0</div>
                    <div class="streak-label">STREAK</div>
                </div>
                <div class="streak-bonus" id="streak-bonus">+0% XP</div>
            </div>

            <!-- Timer -->
            <div class="timer-container">
                <span class="timer-icon">‚è±Ô∏è</span>
                <span class="timer" id="timer">30</span>
            </div>

            <!-- Chess Board -->
            <div class="board-container" id="board-container">
                <div class="chess-board" id="chess-board"></div>
            </div>

            <!-- Puzzle Info -->
            <div class="puzzle-info">
                <div class="puzzle-title" id="puzzle-title">Find the Best Move!</div>
                <div class="puzzle-instruction" id="puzzle-instruction">
                    <span class="highlight" id="to-move">White</span> to move. Find the winning tactic!
                </div>
            </div>

            <!-- Puzzle Navigation -->
            <div class="puzzle-navigation">
                <button class="nav-btn" id="nav-back" onclick="navigatePuzzle(-1)" disabled>
                    <span>‚óÄ Back</span>
                </button>
                <span class="puzzle-position" id="puzzle-position">Puzzle 1</span>
                <button class="nav-btn" id="nav-forward" onclick="navigatePuzzle(1)" disabled>
                    <span>Forward ‚ñ∂</span>
                </button>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Daily Challenge -->
            <div class="panel daily-challenge">
                <div class="panel-title">üéØ Daily Challenge</div>
                <p style="color: var(--light); font-size: 14px;">Complete 5 puzzles for bonus rewards!</p>
                <div class="daily-progress">
                    <div class="daily-dot" id="daily-1">1</div>
                    <div class="daily-dot" id="daily-2">2</div>
                    <div class="daily-dot" id="daily-3">3</div>
                    <div class="daily-dot" id="daily-4">4</div>
                    <div class="daily-dot" id="daily-5">5</div>
                </div>
                <div class="daily-reward">
                    <span style="color: var(--gold);">üéÅ Reward: 500 Coins + Mystery Box</span>
                </div>
            </div>

            <!-- Ranking Progress -->
            <div class="panel">
                <div class="panel-title">üèÜ Your Rank</div>
                <div class="rank-display">
                    <div class="rank-icon" id="rank-icon">‚ôüÔ∏è</div>
                    <div class="rank-info">
                        <div class="rank-name" id="rank-name">Beginner</div>
                        <div class="rank-rating" id="rank-rating-text">Rating: 800</div>
                    </div>
                </div>
                <div class="rank-progress-bar">
                    <div class="rank-progress-fill" id="rank-progress" style="width: 0%"></div>
                </div>
                <div class="rank-labels">
                    <span id="current-rank-label">Beginner</span>
                    <span id="next-rank-label">Amateur</span>
                </div>
            </div>

            <!-- Achievements -->
            <div class="panel">
                <div class="panel-title">üèÖ Achievements</div>
                <div class="achievements-grid">
                    <div class="achievement unlocked" title="First Puzzle">üéØ</div>
                    <div class="achievement locked" title="5 Streak">üî•</div>
                    <div class="achievement locked" title="10 Streak">üí•</div>
                    <div class="achievement locked" title="Perfect Session">‚≠ê</div>
                    <div class="achievement locked" title="Speed Demon">‚ö°</div>
                    <div class="achievement locked" title="Reach 1000 Rating">üéñÔ∏è</div>
                    <div class="achievement locked" title="Reach 1500 Rating">üèÜ</div>
                    <div class="achievement locked" title="Legend">üëë</div>
                </div>
            </div>

            <!-- Multiplier Info -->
            <div class="panel" style="background: linear-gradient(135deg, rgba(0, 206, 201, 0.2), rgba(108, 92, 231, 0.1)); border-color: var(--secondary);">
                <div class="panel-title">üöÄ XP Multipliers</div>
                <div style="font-size: 14px; color: var(--light);">
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>Base XP</span>
                        <span>+25</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>Streak Bonus (3+)</span>
                        <span style="color: var(--fire);">+50%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>Speed Bonus (&lt;10s)</span>
                        <span style="color: var(--secondary);">+25%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>Daily First Win</span>
                        <span style="color: var(--gold);">+100%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Shop Button -->
    <button class="shop-btn" onclick="openShop()">üõí</button>

    <!-- Welcome Modal -->
    <div class="modal-overlay" id="welcome-modal">
        <div class="modal">
            <div class="modal-emoji">‚ôüÔ∏è</div>
            <div class="modal-title">Welcome to ChessBlitz Arena!</div>
            <p style="color: var(--light); margin-bottom: 20px;">
                Solve puzzles, build streaks, and climb the ranks!<br>
                Let's assess your skill with 10 calibration puzzles.
            </p>
            <div class="assessment-progress" id="assessment-progress">
                <div class="assessment-dot current">1</div>
                <div class="assessment-dot">2</div>
                <div class="assessment-dot">3</div>
                <div class="assessment-dot">4</div>
                <div class="assessment-dot">5</div>
                <div class="assessment-dot">6</div>
                <div class="assessment-dot">7</div>
                <div class="assessment-dot">8</div>
                <div class="assessment-dot">9</div>
                <div class="assessment-dot">10</div>
            </div>
            <button class="btn btn-gold" onclick="startAssessment()">START ASSESSMENT</button>
        </div>
    </div>

    <!-- Assessment Complete Modal -->
    <div class="modal-overlay" id="assessment-complete-modal">
        <div class="modal">
            <div class="modal-emoji">üéâ</div>
            <div class="modal-title">Assessment Complete!</div>
            <p style="color: var(--light); margin-bottom: 10px;">Your calibrated rating:</p>
            <div style="font-family: 'Fredoka One', cursive; font-size: 60px; color: var(--gold);" id="final-rating">800</div>
            <div style="font-size: 18px; color: var(--secondary); margin-bottom: 20px;" id="final-rank">Beginner</div>
            <p style="color: var(--light); margin-bottom: 20px;">
                Score: <span id="assessment-score">0</span>/10<br>
                You earned <span style="color: var(--gold);" id="assessment-coins">0</span> coins!
            </p>
            <button class="btn btn-gold" onclick="startTraining()">START TRAINING</button>
        </div>
    </div>

    <!-- Level Up Overlay -->
    <div class="level-up-overlay" id="level-up-overlay">
        <div class="level-up-content">
            <div class="level-up-text">LEVEL UP!</div>
            <div class="level-up-number" id="new-level">2</div>
        </div>
    </div>

    <!-- Confetti Container -->
    <div class="confetti-container" id="confetti-container"></div>

    <!-- Coaching Toast -->
    <div class="coaching-toast" id="coaching-toast" style="display: none;">
        <div class="coach-avatar">ü§ñ</div>
        <div class="coach-message">
            <div class="coach-title" id="coach-title">Coach</div>
            <div class="coach-text" id="coach-text"></div>
        </div>
        <button class="coach-close" onclick="closeCoach()">‚úï</button>
    </div>

    <!-- Profile Management Modal -->
    <div id="profile-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <h2>üë§ Profile Management</h2>

            <!-- Create New Profile -->
            <div class="profile-section">
                <h3>Create New Profile</h3>
                <input type="text" id="new-profile-name" placeholder="Enter player name..." maxlength="30">
                <button onclick="createNewProfile()" class="btn-primary">Create Profile</button>
            </div>

            <!-- Active Profiles -->
            <div class="profile-section">
                <h3>Your Profiles</h3>
                <div id="profile-list">
                    <!-- Populated by JS -->
                </div>
            </div>

            <!-- Archived Profiles (Recoverable) -->
            <div class="profile-section">
                <h3>Archived Profiles <span style="color: var(--gold); font-size: 14px;">(Recoverable)</span></h3>
                <div id="archived-profile-list">
                    <!-- Populated by JS -->
                </div>
            </div>

            <!-- Export/Import -->
            <div class="profile-section">
                <h3>Backup & Recovery</h3>
                <button onclick="exportAllProfiles()" class="btn-secondary">üì• Export All Profiles</button>
                <button onclick="document.getElementById('import-file').click()" class="btn-secondary">üì§ Import Profiles</button>
                <input type="file" id="import-file" accept=".json" style="display:none" onchange="importProfiles(event)">
            </div>

            <button onclick="closeProfileManagement()" class="close-modal">Close</button>
        </div>
    </div>

    <script>
        // ==================== LOGGING SYSTEM ====================
        class Logger {
            constructor() {
                this.logs = [];
                this.maxLogs = 500;
                this.sessionId = this.generateSessionId();
                this.init();
            }

            init() {
                this.log('info', 'ChessBlitz Arena started', { sessionId: this.sessionId, timestamp: new Date().toISOString(), userAgent: navigator.userAgent });
                this.setupErrorHandlers();
                this.loadPreviousLogs();
            }

            generateSessionId() {
                return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            log(level, message, data = {}) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    level,
                    message,
                    sessionId: this.sessionId,
                    ...data
                };

                this.logs.push(logEntry);

                // Keep only recent logs
                if (this.logs.length > this.maxLogs) {
                    this.logs = this.logs.slice(-this.maxLogs);
                }

                // Console output with color
                const colors = {
                    error: 'color: #e74c3c; font-weight: bold;',
                    warn: 'color: #f39c12;',
                    info: 'color: #3498db;',
                    success: 'color: #2ecc71;',
                    debug: 'color: #95a5a6;'
                };
                console.log(`%c[${level.toUpperCase()}] ${message}`, colors[level] || '', data);

                // Save to localStorage
                this.saveLogs();
            }

            saveLogs() {
                try {
                    localStorage.setItem('chessBlitzLogs', JSON.stringify(this.logs.slice(-100)));
                } catch (e) {
                    console.error('Failed to save logs:', e);
                }
            }

            loadPreviousLogs() {
                try {
                    const saved = localStorage.getItem('chessBlitzLogs');
                    if (saved) {
                        const previousLogs = JSON.parse(saved);
                        this.log('info', `Loaded ${previousLogs.length} previous log entries`);
                    }
                } catch (e) {
                    this.log('error', 'Failed to load previous logs', { error: e.message });
                }
            }

            setupErrorHandlers() {
                // Global error handler
                window.addEventListener('error', (event) => {
                    this.log('error', 'Uncaught error', {
                        message: event.message,
                        filename: event.filename,
                        lineno: event.lineno,
                        colno: event.colno,
                        error: event.error ? event.error.stack : null
                    });
                });

                // Promise rejection handler
                window.addEventListener('unhandledrejection', (event) => {
                    this.log('error', 'Unhandled promise rejection', {
                        reason: event.reason,
                        promise: event.promise
                    });
                });

                // Console override for capturing all console logs
                const originalConsoleError = console.error;
                console.error = (...args) => {
                    this.log('error', 'Console error', { args: args.map(a => String(a)) });
                    originalConsoleError.apply(console, args);
                };
            }

            trackAction(action, details = {}) {
                this.log('info', `User action: ${action}`, details);
            }

            trackPuzzle(puzzleData) {
                this.log('info', 'Puzzle event', puzzleData);
            }

            trackPerformance(metric, value) {
                this.log('debug', `Performance: ${metric}`, { value });
            }

            getLogs(level = null) {
                if (level) {
                    return this.logs.filter(log => log.level === level);
                }
                return this.logs;
            }

            exportLogs() {
                const dataStr = JSON.stringify(this.logs, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `chessblitz-logs-${this.sessionId}.json`;
                link.click();
                this.log('info', 'Logs exported');
            }

            clearLogs() {
                this.logs = [];
                localStorage.removeItem('chessBlitzLogs');
                this.log('info', 'Logs cleared');
            }
        }

        // Initialize logger globally
        const logger = new Logger();

        // Add debug console commands
        window.chessDebug = {
            getLogs: () => logger.getLogs(),
            getErrors: () => logger.getLogs('error'),
            exportLogs: () => logger.exportLogs(),
            clearLogs: () => logger.clearLogs(),
            showStats: () => console.table(gameState)
        };

        logger.log('info', 'Debug console available: chessDebug.getLogs(), chessDebug.getErrors(), chessDebug.exportLogs()');

        // ==================== AI ENGINE (Stockfish) ====================
        class AIEngine {
            constructor() {
                this.engine = null;
                this.isReady = false;
                this.currentAnalysis = null;
                this.initAttempts = 0;
                this.maxInitAttempts = 10;
                this.initRetryDelay = 500; // ms
                this.init();
            }

            init() {
                this.initAttempts++;
                try {
                    if (typeof STOCKFISH === 'function') {
                        this.engine = STOCKFISH();
                        this.setupEngine();
                        logger.log('success', `Stockfish AI engine initialized (attempt ${this.initAttempts})`);
                    } else if (this.initAttempts < this.maxInitAttempts) {
                        // CDN may still be loading, retry after delay
                        logger.log('info', `Stockfish not ready, retrying... (attempt ${this.initAttempts}/${this.maxInitAttempts})`);
                        setTimeout(() => this.init(), this.initRetryDelay);
                    } else {
                        logger.log('warn', 'Stockfish not available after max retries, AI hints disabled');
                    }
                } catch (e) {
                    logger.log('error', 'Failed to initialize Stockfish', { error: e.message });
                    if (this.initAttempts < this.maxInitAttempts) {
                        setTimeout(() => this.init(), this.initRetryDelay);
                    }
                }
            }

            setupEngine() {
                this.engine.onmessage = (event) => {
                    const line = event.data || event;

                    if (line.includes('readyok')) {
                        this.isReady = true;
                        logger.log('info', 'Stockfish engine ready');
                    }

                    if (line.includes('bestmove')) {
                        const match = line.match(/bestmove\s+(\S+)/);
                        if (match) {
                            this.currentAnalysis = {
                                bestMove: match[1],
                                timestamp: Date.now()
                            };
                            logger.log('info', 'AI analysis complete', this.currentAnalysis);
                        }
                    }

                    // Parse evaluation score
                    if (line.includes('score cp')) {
                        const match = line.match(/score cp\s+(-?\d+)/);
                        if (match && this.currentAnalysis) {
                            this.currentAnalysis.score = parseInt(match[1]) / 100; // Convert centipawns to pawns
                        }
                    }
                };

                // Initialize engine
                this.engine.postMessage('uci');
                this.engine.postMessage('isready');
            }

            async waitForReady(timeout = 5000) {
                if (this.isReady) return true;
                return new Promise((resolve) => {
                    const startTime = Date.now();
                    const checkInterval = setInterval(() => {
                        if (this.isReady) {
                            clearInterval(checkInterval);
                            resolve(true);
                        } else if (Date.now() - startTime > timeout) {
                            clearInterval(checkInterval);
                            logger.log('warn', 'AI engine wait timeout');
                            resolve(false);
                        }
                    }, 100);
                });
            }

            async analyzePosition(fen, depth = 15) {
                // Wait for engine to be ready (with timeout)
                if (!this.isReady) {
                    logger.log('info', 'Waiting for AI engine to be ready...');
                    const ready = await this.waitForReady(5000);
                    if (!ready) {
                        logger.log('warn', 'AI engine not ready after waiting');
                        return null;
                    }
                }

                if (!this.engine) {
                    logger.log('warn', 'AI engine not available');
                    return null;
                }

                this.currentAnalysis = null;

                // Set position
                this.engine.postMessage('ucinewgame');
                this.engine.postMessage(`position fen ${fen}`);
                this.engine.postMessage(`go depth ${depth}`);

                logger.log('info', 'AI analyzing position...', { fen, depth });

                // Wait for analysis (max 10 seconds)
                return new Promise((resolve) => {
                    const startTime = Date.now();
                    const checkInterval = setInterval(() => {
                        if (this.currentAnalysis) {
                            clearInterval(checkInterval);
                            resolve(this.currentAnalysis);
                        } else if (Date.now() - startTime > 10000) {
                            clearInterval(checkInterval);
                            logger.log('warn', 'AI analysis timeout');
                            resolve(null);
                        }
                    }, 100);
                });
            }

            convertMoveToReadable(move) {
                // Convert UCI move (e2e4) to readable format (e2-e4 or piece name)
                if (move.length === 4) {
                    return `${move.slice(0, 2)}-${move.slice(2, 4)}`;
                }
                return move;
            }
        }

        // Initialize AI engine
        const aiEngine = new AIEngine();

        // Add AI to debug console
        window.chessDebug.getAIAnalysis = (fen) => aiEngine.analyzePosition(fen || gameState.currentPuzzle?.fen);

        // ==================== GAME STATE ====================
        const gameState = {
            // Player stats
            coins: 500,
            rating: 800,
            level: 1,
            xp: 0,
            xpToLevel: 100,

            // Session stats
            streak: 0,
            bestStreak: 0,
            puzzlesSolved: 0,
            puzzlesAttempted: 0,
            ratingGained: 0,
            dailyCompleted: 0,

            // Power-ups
            powers: {
                hint: 3,
                freeze: 2,
                skip: 1,
                double: 1
            },

            // Active effects
            doubleXpActive: false,
            timerFrozen: false,

            // Theme
            currentTheme: 'classic',
            unlockedThemes: ['classic', 'neon', 'ice', 'fire', 'royal'],

            // Assessment
            inAssessment: true,
            assessmentPuzzle: 0,
            assessmentScore: 0,
            assessmentResults: [],

            // Current puzzle
            currentPuzzle: null,
            selectedSquare: null,
            timer: 30,
            timerInterval: null,
            moveHistory: [],

            // Puzzle navigation
            puzzleHistory: [],
            puzzleHistoryIndex: -1,
            hintUsed: false,

            // Bootcamp state
            inBootcamp: false,
            bootcampDay: 0,
            bootcampStartTime: null,
            bootcampMode: 'learning',
            bootcampSessionStart: null,
            bootcampPuzzlesToday: 0,
            bootcampTargetToday: 0,

            // Theme performance tracking (adaptive core)
            themeStats: {},

            // Session tracking
            sessionPuzzles: [],
            sessionStartTime: null,
            sessionBreaks: [],

            // Daily progress
            dailyStats: {
                day1: null,
                day2: null,
                day3: null,
                day4: null,
                day5: null
            },

            // Chess.js instance for move validation
            chessInstance: null
        };

        // ==================== PUZZLE DATABASE ====================
        // Puzzles organized by difficulty (rating)
        // Will be loaded from puzzles.json or fall back to minimal set
        let puzzleDatabase = {
            // 600-800: Very Easy - Basic captures and simple tactics
            beginner: [
                {
                    fen: "r1bqkb1r/pppp1ppp/2n2n2/4p2Q/2B1P3/8/PPPP1PPP/RNB1K1NR w KQkq - 4 4",
                    solution: ["h5f7"],
                    hint: "Look for a checkmate in one!",
                    title: "Scholar's Mate",
                    toMove: "White",
                    rating: 600
                },
                {
                    fen: "rnbqkbnr/ppp2ppp/8/3pp3/4P3/3B4/PPPP1PPP/RNBQK1NR w KQkq - 0 3",
                    solution: ["d3h7"],
                    hint: "Attack an undefended piece!",
                    title: "Free Pawn",
                    toMove: "White",
                    rating: 650
                },
                {
                    fen: "r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 2 3",
                    solution: ["f3g5"],
                    hint: "Attack f7 with your knight!",
                    title: "Fried Liver Setup",
                    toMove: "White",
                    rating: 700
                },
                {
                    fen: "rnbqkbnr/pppp1ppp/8/4p3/6P1/5P2/PPPPP2P/RNBQKBNR b KQkq - 0 2",
                    solution: ["d8h4"],
                    hint: "Check the king!",
                    title: "Early Queen Attack",
                    toMove: "Black",
                    rating: 650
                },
                {
                    fen: "r1bqkb1r/pppp1ppp/2n2n2/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4",
                    solution: ["f3e5"],
                    hint: "Capture the pawn!",
                    title: "Center Control",
                    toMove: "White",
                    rating: 700
                }
            ],

            // 800-1000: Easy - Simple tactics, forks, pins
            easy: [
                {
                    fen: "r1bqkb1r/pppp1ppp/2n2n2/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4",
                    solution: ["b5c6"],
                    hint: "Capture the knight and attack the king!",
                    title: "Pin and Win",
                    toMove: "White",
                    rating: 850
                },
                {
                    fen: "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3",
                    solution: ["f1b5"],
                    hint: "Pin the knight to the king!",
                    title: "Spanish Pin",
                    toMove: "White",
                    rating: 800
                },
                {
                    fen: "rnbqkbnr/ppp2ppp/8/4p3/2B1P3/8/PPPP1PPP/RNBQK1NR w KQkq - 0 3",
                    solution: ["c4f7"],
                    hint: "Attack the weak f7 square!",
                    title: "f7 Weakness",
                    toMove: "White",
                    rating: 900
                },
                {
                    fen: "r1bqk2r/pppp1ppp/2n2n2/2b1p3/2B1P3/3P1N2/PPP2PPP/RNBQK2R b KQkq - 0 5",
                    solution: ["c5f2"],
                    hint: "Attack with your bishop!",
                    title: "Bishop Attack",
                    toMove: "Black",
                    rating: 950
                },
                {
                    fen: "r1bqkbnr/pppp1ppp/2n5/4p3/3PP3/8/PPP2PPP/RNBQKBNR b KQkq d3 0 3",
                    solution: ["e5d4"],
                    hint: "Capture the center pawn!",
                    title: "Center Exchange",
                    toMove: "Black",
                    rating: 850
                }
            ],

            // 1000-1200: Intermediate - Two-move tactics, discovered attacks
            intermediate: [
                {
                    fen: "r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4",
                    solution: ["e8f7"],
                    hint: "You must capture the queen!",
                    title: "Forced Capture",
                    toMove: "Black",
                    rating: 1050
                },
                {
                    fen: "rnbqk2r/pppp1ppp/5n2/2b1p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4",
                    solution: ["f3e5"],
                    hint: "Fork the bishop and f7!",
                    title: "Knight Fork",
                    toMove: "White",
                    rating: 1100
                },
                {
                    fen: "r1bqkbnr/pppp1ppp/2n5/4N3/4P3/8/PPPP1PPP/RNBQKB1R b KQkq - 0 3",
                    solution: ["c6e5"],
                    hint: "Capture the attacking knight!",
                    title: "Piece Recovery",
                    toMove: "Black",
                    rating: 1000
                },
                {
                    fen: "rnbqkb1r/ppp2ppp/3p1n2/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 0 4",
                    solution: ["f3g5"],
                    hint: "Attack f7 with a discovered attack setup!",
                    title: "Ng5 Attack",
                    toMove: "White",
                    rating: 1150
                },
                {
                    fen: "r1bqkbnr/1ppp1ppp/p1n5/4p3/B3P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 0 4",
                    solution: ["a4c6"],
                    hint: "Win the knight with check!",
                    title: "Bishop Capture",
                    toMove: "White",
                    rating: 1100
                }
            ],

            // 1200-1400: Advanced - Complex combinations
            advanced: [
                {
                    fen: "r1bq1rk1/pppp1ppp/2n2n2/2b1p3/2B1P3/3P1N2/PPP2PPP/RNBQ1RK1 w - - 6 6",
                    solution: ["c1g5"],
                    hint: "Pin the knight to the queen!",
                    title: "Powerful Pin",
                    toMove: "White",
                    rating: 1250
                },
                {
                    fen: "r1bqk2r/ppp2ppp/2n2n2/2bpp3/2B1P3/2NP1N2/PPP2PPP/R1BQK2R w KQkq - 0 6",
                    solution: ["e4d5"],
                    hint: "Open up the center!",
                    title: "Center Break",
                    toMove: "White",
                    rating: 1300
                },
                {
                    fen: "r1bqkb1r/pppp1ppp/2n2n2/4p3/2B1P3/2N2N2/PPPP1PPP/R1BQK2R b KQkq - 5 4",
                    solution: ["f6e4"],
                    hint: "Attack the center!",
                    title: "Knight Centralization",
                    toMove: "Black",
                    rating: 1350
                },
                {
                    fen: "rnbqk2r/pppp1ppp/5n2/2b1p3/4P3/2N2N2/PPPP1PPP/R1BQKB1R w KQkq - 4 4",
                    solution: ["f3e5"],
                    hint: "Attack the center with tempo!",
                    title: "Aggressive Knight",
                    toMove: "White",
                    rating: 1300
                },
                {
                    fen: "r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 3 3",
                    solution: ["g8f6"],
                    hint: "Develop with attack!",
                    title: "Two Knights Defense",
                    toMove: "Black",
                    rating: 1250
                }
            ],

            // 1400+: Expert - Deep tactics
            expert: [
                {
                    fen: "r1bqk2r/pppp1ppp/2n2n2/2b1p3/2B1P3/2NP1N2/PPP2PPP/R1BQK2R b KQkq - 0 5",
                    solution: ["c5g1"],
                    hint: "Attack the weak point!",
                    title: "Diagonal Strike",
                    toMove: "Black",
                    rating: 1450
                },
                {
                    fen: "r1bq1rk1/ppp2ppp/2np1n2/2b1p3/2B1P3/2NP1N2/PPP2PPP/R1BQ1RK1 w - - 0 7",
                    solution: ["c3d5"],
                    hint: "Sacrifice for position!",
                    title: "Knight Sacrifice",
                    toMove: "White",
                    rating: 1500
                },
                {
                    fen: "r1bqkb1r/1ppp1ppp/p1n2n2/4p3/B3P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 0 4",
                    solution: ["a4a5"],
                    hint: "Retreat to safety while keeping pressure!",
                    title: "Strategic Retreat",
                    toMove: "White",
                    rating: 1550
                },
                {
                    fen: "r1bqk2r/ppp2ppp/2n2n2/3pp3/1bP1P3/2N2N2/PP1P1PPP/R1BQKB1R w KQkq - 0 5",
                    solution: ["e4d5"],
                    hint: "Open up lines!",
                    title: "Pawn Break",
                    toMove: "White",
                    rating: 1600
                },
                {
                    fen: "rnbqkb1r/pp3ppp/2p2n2/3pp3/2B1P3/2N2N2/PPPP1PPP/R1BQK2R w KQkq - 0 5",
                    solution: ["e4e5"],
                    hint: "Push forward!",
                    title: "Pawn Storm",
                    toMove: "White",
                    rating: 1500
                }
            ]
        };

        // ==================== PUZZLE LOADER ====================
        async function loadPuzzleDatabase() {
            try {
                logger.log('info', 'Loading Lichess puzzle database...');
                const response = await fetch('puzzles.json');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                // Replace the minimal fallback database with full Lichess database
                puzzleDatabase = data.tiers;

                logger.log('success', `Loaded ${data.meta.total_puzzles} puzzles from Lichess database`);
                logger.log('info', 'Puzzle distribution:', {
                    beginner: puzzleDatabase.beginner.length,
                    easy: puzzleDatabase.easy.length,
                    intermediate: puzzleDatabase.intermediate.length,
                    advanced: puzzleDatabase.advanced.length,
                    expert: puzzleDatabase.expert.length,
                    master: puzzleDatabase.master?.length || 0
                });

                return true;
            } catch (error) {
                logger.log('warn', 'Could not load puzzles.json, using fallback database', { error: error.message });
                logger.log('info', 'Fallback puzzle count:', {
                    beginner: puzzleDatabase.beginner.length,
                    easy: puzzleDatabase.easy.length,
                    intermediate: puzzleDatabase.intermediate.length,
                    advanced: puzzleDatabase.advanced.length,
                    expert: puzzleDatabase.expert.length
                });
                return false;
            }
        }

        // ==================== BOOTCAMP CURRICULUM ====================
        let bootcampCurriculum = null;

        async function loadBootcampCurriculum() {
            try {
                logger.log('info', 'Loading bootcamp curriculum...');
                const response = await fetch('bootcamp-curriculum.json');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                bootcampCurriculum = await response.json();

                logger.log('success', 'Loaded bootcamp curriculum', {
                    days: bootcampCurriculum.daily_targets.length,
                    theme_pools: Object.keys(bootcampCurriculum.theme_pools).length
                });

                return true;
            } catch (error) {
                logger.log('error', 'Failed to load bootcamp curriculum', { error: error.message });
                return false;
            }
        }

        // ==================== RANK SYSTEM ====================
        const ranks = [
            { name: "Beginner", minRating: 0, icon: "‚ôüÔ∏è", color: "#95a5a6" },
            { name: "Amateur", minRating: 900, icon: "‚ôû", color: "#3498db" },
            { name: "Intermediate", minRating: 1100, icon: "‚ôù", color: "#2ecc71" },
            { name: "Advanced", minRating: 1300, icon: "‚ôú", color: "#9b59b6" },
            { name: "Expert", minRating: 1500, icon: "‚ôõ", color: "#e74c3c" },
            { name: "Master", minRating: 1700, icon: "‚ôö", color: "#f39c12" },
            { name: "Grandmaster", minRating: 2000, icon: "üëë", color: "#fdcb6e" }
        ];

        // ==================== ACHIEVEMENTS ====================
        const achievements = [
            { id: "first_puzzle", name: "First Puzzle", icon: "üéØ", condition: (s) => s.puzzlesSolved >= 1 },
            { id: "streak_5", name: "5 Streak", icon: "üî•", condition: (s) => s.bestStreak >= 5 },
            { id: "streak_10", name: "10 Streak", icon: "üí•", condition: (s) => s.bestStreak >= 10 },
            { id: "perfect", name: "Perfect Session", icon: "‚≠ê", condition: (s) => s.puzzlesSolved >= 10 && s.puzzlesAttempted === s.puzzlesSolved },
            { id: "speed", name: "Speed Demon", icon: "‚ö°", condition: (s) => false }, // Special trigger
            { id: "rating_1000", name: "1000 Rating", icon: "üéñÔ∏è", condition: (s) => s.rating >= 1000 },
            { id: "rating_1500", name: "1500 Rating", icon: "üèÜ", condition: (s) => s.rating >= 1500 },
            { id: "legend", name: "Legend", icon: "üëë", condition: (s) => s.rating >= 2000 }
        ];

        // ==================== INITIALIZATION ====================
        async function init() {
            // Load puzzle database first
            await loadPuzzleDatabase();
            await loadBootcampCurriculum();

            // Initialize profile system (creates default profile if none exist)
            initializeProfiles();

            createParticles();
            // loadGameState(); // Removed - now handled by profile system
            renderBoard();
            updateAllDisplays();
            showWelcomeModal();
            setupKeyboardShortcuts();
        }

        function setupKeyboardShortcuts() {
            // Keyboard shortcuts for puzzle navigation
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        navigatePuzzle(-1);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        navigatePuzzle(1);
                        break;
                    case 'Escape':
                        e.preventDefault();
                        deselectPiece();
                        break;
                }
            });
        }

        function deselectPiece() {
            gameState.selectedSquare = null;
            renderBoard();
        }

        function createParticles() {
            const container = document.getElementById('particles');
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (10 + Math.random() * 10) + 's';
                particle.style.background = `rgba(${Math.random() > 0.5 ? '108, 92, 231' : '0, 206, 201'}, ${0.2 + Math.random() * 0.3})`;
                container.appendChild(particle);
            }
        }

        function loadGameState() {
            const saved = localStorage.getItem('chessBlitzState');
            if (saved) {
                const parsed = JSON.parse(saved);
                Object.assign(gameState, parsed);
                gameState.inAssessment = false; // Don't repeat assessment
            }
        }

        function saveGameState() {
            const toSave = {
                coins: gameState.coins,
                rating: gameState.rating,
                level: gameState.level,
                xp: gameState.xp,
                xpToLevel: gameState.xpToLevel,
                bestStreak: gameState.bestStreak,
                powers: gameState.powers,
                currentTheme: gameState.currentTheme,
                unlockedThemes: gameState.unlockedThemes,
                dailyCompleted: gameState.dailyCompleted,
                // Bootcamp state
                inBootcamp: gameState.inBootcamp,
                bootcampDay: gameState.bootcampDay,
                bootcampStartTime: gameState.bootcampStartTime,
                bootcampMode: gameState.bootcampMode,
                bootcampSessionStart: gameState.bootcampSessionStart,
                bootcampPuzzlesToday: gameState.bootcampPuzzlesToday,
                bootcampTargetToday: gameState.bootcampTargetToday,
                themeStats: gameState.themeStats,
                sessionPuzzles: gameState.sessionPuzzles,
                sessionBreaks: gameState.sessionBreaks,
                dailyStats: gameState.dailyStats
            };
            localStorage.setItem('chessBlitzState', JSON.stringify(toSave));
        }

        // ==================== CHESS BOARD ====================
        const pieceMap = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };

        function fenToBoard(fen) {
            const board = [];
            const rows = fen.split(' ')[0].split('/');

            for (const row of rows) {
                const boardRow = [];
                for (const char of row) {
                    if (isNaN(char)) {
                        boardRow.push(char);
                    } else {
                        for (let i = 0; i < parseInt(char); i++) {
                            boardRow.push(null);
                        }
                    }
                }
                board.push(boardRow);
            }
            return board;
        }

        function renderBoard() {
            const boardElement = document.getElementById('chess-board');
            boardElement.innerHTML = '';

            if (!gameState.currentPuzzle) {
                // Show empty board
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        boardElement.appendChild(square);
                    }
                }
                return;
            }

            const board = fenToBoard(gameState.currentPuzzle.fen);
            const isBlackToMove = gameState.currentPuzzle.toMove === 'Black';

            // Flip board based on who's to move (player's pieces always at bottom)
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    // For display: flip the board so player's pieces are at bottom
                    // FEN board[0] = rank 8 (black's back rank), board[7] = rank 1 (white's back rank)
                    // Black to move: flip vertically so black (board[0]) shows at bottom
                    // White to move: don't flip, white (board[7]) already at bottom
                    const displayRow = isBlackToMove ? 7 - row : row;
                    const displayCol = isBlackToMove ? 7 - col : col;
                    const actualRow = row;  // ‚úÖ Always use actual row from FEN board array (never flip for logic)

                    const square = document.createElement('div');
                    square.className = `square ${(displayRow + displayCol) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = actualRow;
                    square.dataset.col = displayCol;

                    const piece = board[actualRow][displayCol];
                    if (piece) {
                        square.textContent = pieceMap[piece];
                        // Add color class based on piece case (uppercase = white, lowercase = black)
                        const isWhitePiece = piece === piece.toUpperCase();
                        square.classList.add(isWhitePiece ? 'white-piece' : 'black-piece');

                        // Make piece draggable only if it's the player's turn
                        const isBlackToMove = gameState.currentPuzzle.toMove === 'Black';
                        if ((isBlackToMove && !isWhitePiece) || (!isBlackToMove && isWhitePiece)) {
                            square.draggable = true;
                            square.style.cursor = 'grab';

                            square.addEventListener('dragstart', (e) => handleDragStart(e, actualRow, displayCol));
                            square.addEventListener('dragend', (e) => handleDragEnd(e));
                        }
                    }

                    // Make all squares droppable
                    square.addEventListener('dragover', (e) => handleDragOver(e));
                    square.addEventListener('drop', (e) => handleDrop(e, actualRow, displayCol));

                    square.addEventListener('click', () => handleSquareClick(actualRow, displayCol));

                    // Add hover to show legal moves
                    square.addEventListener('mouseenter', () => handleSquareHover(actualRow, displayCol));
                    square.addEventListener('mouseleave', () => clearLegalMoveHighlights());

                    boardElement.appendChild(square);
                }
            }
        }

        // Show legal moves when hovering over a piece
        function handleSquareHover(row, col) {
            if (!gameState.currentPuzzle) return;

            const board = fenToBoard(gameState.currentPuzzle.fen);
            const piece = board[row][col];
            const isWhiteToMove = gameState.currentPuzzle.toMove === 'White';

            if (piece) {
                const isWhitePiece = piece === piece.toUpperCase();

                // Only show legal moves for pieces that match the side to move
                if ((isWhiteToMove && isWhitePiece) || (!isWhiteToMove && !isWhitePiece)) {
                    const legalMoves = getLegalMoves(row, col);

                    legalMoves.forEach(move => {
                        const targetSquare = document.querySelector(`.square[data-row="${move.toRow}"][data-col="${move.toCol}"]`);
                        if (targetSquare) {
                            targetSquare.classList.add('legal-move');
                            // Check if target square has a piece (for capture highlight)
                            if (targetSquare.textContent) {
                                targetSquare.classList.add('has-piece');
                            }
                        }
                    });
                }
            }
        }

        // Clear all legal move highlights
        function clearLegalMoveHighlights() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(sq => {
                sq.classList.remove('legal-move', 'has-piece');
            });
        }

        // Drag and drop handlers
        let draggedPiece = null;

        function handleDragStart(e, row, col) {
            draggedPiece = { row, col };
            e.target.style.opacity = '0.4';
            e.target.style.cursor = 'grabbing';

            // Show legal moves when dragging starts
            handleSquareHover(row, col);

            logger.trackAction('drag_start', { row, col });
        }

        function handleDragEnd(e) {
            e.target.style.opacity = '1';
            e.target.style.cursor = 'grab';

            // Clear legal move highlights
            clearLegalMoveHighlights();
        }

        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow drop
            return false;
        }

        function handleDrop(e, toRow, toCol) {
            e.stopPropagation();
            e.preventDefault();

            if (!draggedPiece) return;

            const fromRow = draggedPiece.row;
            const fromCol = draggedPiece.col;

            // Don't do anything if dropping on same square
            if (fromRow === toRow && fromCol === toCol) {
                draggedPiece = null;
                return;
            }

            const move = squareToAlgebraic(fromRow, fromCol) + squareToAlgebraic(toRow, toCol);
            logger.trackAction('drop_move', { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol }, move });

            // Check the move
            checkMove(move, toRow, toCol);

            draggedPiece = null;
            return false;
        }

        function handleSquareClick(row, col) {
            if (!gameState.currentPuzzle) return;

            const board = fenToBoard(gameState.currentPuzzle.fen);
            const piece = board[row][col];
            const isWhiteToMove = gameState.currentPuzzle.toMove === 'White';

            logger.trackAction('square_click', { row, col, piece, toMove: gameState.currentPuzzle.toMove });

            if (gameState.selectedSquare === null) {
                // First click - select piece (only if it belongs to the player)
                if (piece) {
                    const isWhitePiece = piece === piece.toUpperCase();

                    // Only allow selecting pieces that match the side to move
                    if ((isWhiteToMove && isWhitePiece) || (!isWhiteToMove && !isWhitePiece)) {
                        gameState.selectedSquare = { row, col };
                        // Use data attributes to find the correct square (handles board flipping)
                        const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                        if (square) {
                            square.classList.add('selected');
                        }
                        logger.trackAction('piece_selected', { row, col, piece });
                    } else {
                        logger.trackAction('wrong_color_selected', { row, col, piece, expected: isWhiteToMove ? 'White' : 'Black' });
                    }
                }
            } else {
                // Second click - check if it's the same square (deselect) or a move
                const from = gameState.selectedSquare;

                // If clicking the same square, just deselect
                if (from.row === row && from.col === col) {
                    const squares = document.querySelectorAll('.square');
                    squares.forEach(sq => sq.classList.remove('selected'));
                    gameState.selectedSquare = null;
                    logger.trackAction('piece_deselected', { row, col });
                    return;
                }

                // Check if this is a legal move
                const legalMoves = getLegalMoves(from.row, from.col);
                const isLegalMove = legalMoves.some(move => move.toRow === row && move.toCol === col);

                if (isLegalMove) {
                    // It's a legal move - attempt it
                    const move = squareToAlgebraic(from.row, from.col) + squareToAlgebraic(row, col);
                    logger.trackAction('move_attempt', { from, to: {row, col}, move });

                    // Clear selection
                    const squares = document.querySelectorAll('.square');
                    squares.forEach(sq => sq.classList.remove('selected'));
                    gameState.selectedSquare = null;

                    // Check if move is correct
                    checkMove(move, row, col);
                } else {
                    // Not a legal move - deselect
                    const squares = document.querySelectorAll('.square');
                    squares.forEach(sq => sq.classList.remove('selected'));
                    gameState.selectedSquare = null;
                    logger.trackAction('invalid_destination_clicked', { from, to: {row, col} });
                }
            }
        }

        function squareToAlgebraic(row, col) {
            const files = 'abcdefgh';
            const ranks = '87654321';
            return files[col] + ranks[row];
        }

        function checkMove(move, toRow, toCol) {
            const puzzle = gameState.currentPuzzle;

            // Use data attributes to find the correct square (handles board flipping)
            const targetSquare = document.querySelector(`.square[data-row="${toRow}"][data-col="${toCol}"]`);

            // First, validate if the move is legal according to chess rules
            if (gameState.chessInstance) {
                const moveResult = gameState.chessInstance.move({
                    from: move.substring(0, 2),
                    to: move.substring(2, 4),
                    promotion: 'q' // Always promote to queen for simplicity
                });

                if (!moveResult) {
                    // Illegal move - shake and show error
                    targetSquare.classList.add('illegal');
                    setTimeout(() => targetSquare.classList.remove('illegal'), 500);
                    showFeedback('That move is not legal! Try again.', 'error');
                    logger.trackAction('illegal_move', { move });
                    return;
                }

                // Move is legal - now check if it's the correct solution
                const isCorrect = puzzle.solution.includes(move);

                if (isCorrect) {
                    targetSquare.classList.add('correct');
                    setTimeout(() => targetSquare.classList.remove('correct'), 500);
                    handleCorrectAnswer();
                } else {
                    // Legal move but wrong solution - undo the move in chess instance
                    gameState.chessInstance.undo();
                    targetSquare.classList.add('wrong');
                    setTimeout(() => targetSquare.classList.remove('wrong'), 500);
                    handleWrongAnswer();
                }
            } else {
                // Fallback if Chess.js not available - just check solution
                const isCorrect = puzzle.solution.includes(move);
                if (isCorrect) {
                    targetSquare.classList.add('correct');
                    setTimeout(() => targetSquare.classList.remove('correct'), 500);
                    handleCorrectAnswer();
                } else {
                    targetSquare.classList.add('wrong');
                    setTimeout(() => targetSquare.classList.remove('wrong'), 500);
                    handleWrongAnswer();
                }
            }
        }

        // ==================== GAME LOGIC ====================
        function handleCorrectAnswer() {
            clearInterval(gameState.timerInterval);

            gameState.puzzlesSolved++;
            gameState.streak++;

            logger.trackAction('puzzle_correct', {
                puzzle: gameState.currentPuzzle?.title,
                rating: gameState.currentPuzzle?.rating,
                streak: gameState.streak,
                timeLeft: gameState.timer
            });
            if (gameState.streak > gameState.bestStreak) {
                gameState.bestStreak = gameState.streak;
            }

            // Calculate rewards
            let xpGained = 25;
            let coinsGained = 10;
            let ratingGained = calculateRatingGain();

            // Streak bonus
            if (gameState.streak >= 3) {
                xpGained = Math.floor(xpGained * 1.5);
                coinsGained = Math.floor(coinsGained * 1.3);
                ratingGained = Math.floor(ratingGained * 1.2);
            }

            // Speed bonus (solved in under 10 seconds)
            const timeUsed = 30 - gameState.timer;
            if (timeUsed < 10) {
                xpGained = Math.floor(xpGained * 1.25);
                coinsGained += 5;
            }

            // Double XP power-up
            if (gameState.doubleXpActive) {
                xpGained *= 2;
                gameState.doubleXpActive = false;
            }

            // Apply rewards
            gameState.coins += coinsGained;
            gameState.rating += ratingGained;
            gameState.ratingGained += ratingGained;
            addXP(xpGained);

            // Show XP popup
            showXPPopup(xpGained);
            showRatingChange(ratingGained);

            // Update daily progress
            if (gameState.dailyCompleted < 5) {
                gameState.dailyCompleted++;
                updateDailyProgress();
            }

            // Spawn confetti
            spawnConfetti();

            // Assessment mode
            if (gameState.inAssessment) {
                gameState.assessmentScore++;
                gameState.assessmentResults.push(true);
                updateAssessmentProgress();

                if (gameState.assessmentPuzzle >= 10) {
                    completeAssessment();
                    return;
                }
            }

            // Check achievements
            checkAchievements();

            // Bootcamp mode: Track theme performance
            if (gameState.inBootcamp && gameState.currentPuzzle) {
                const themes = gameState.currentPuzzle.themes || [];
                const timeSpent = 30 - gameState.timer;
                updateThemeStats(themes, true);

                // Update session tracking
                const lastPuzzle = gameState.sessionPuzzles[gameState.sessionPuzzles.length - 1];
                if (lastPuzzle && lastPuzzle.puzzleId === gameState.currentPuzzle.id) {
                    lastPuzzle.correct = true;
                    lastPuzzle.timeSpent = timeSpent;
                }

                // Check for coaching triggers
                checkCoachingTriggers(gameState.currentPuzzle, true, timeSpent);
            }

            updateAllDisplays();
            saveGameState();

            // Load next puzzle after delay
            setTimeout(() => loadNextPuzzle(), 1000);
        }

        function handleWrongAnswer() {
            gameState.puzzlesAttempted++;
            gameState.streak = 0;

            logger.trackAction('puzzle_wrong', {
                puzzle: gameState.currentPuzzle?.title,
                rating: gameState.currentPuzzle?.rating,
                timeLeft: gameState.timer
            });

            // Rating loss (smaller than gain for encouragement)
            const ratingLoss = Math.floor(calculateRatingGain() * 0.5);
            gameState.rating = Math.max(100, gameState.rating - ratingLoss);
            gameState.ratingGained -= ratingLoss;

            showRatingChange(-ratingLoss);

            // Assessment mode
            if (gameState.inAssessment) {
                gameState.assessmentResults.push(false);
                updateAssessmentProgress();

                if (gameState.assessmentPuzzle >= 10) {
                    completeAssessment();
                    return;
                }

                // Move to next puzzle in assessment
                setTimeout(() => loadNextPuzzle(), 1500);
            }

            // Bootcamp mode: Track theme performance
            if (gameState.inBootcamp && gameState.currentPuzzle) {
                const themes = gameState.currentPuzzle.themes || [];
                const timeSpent = 30 - gameState.timer;
                updateThemeStats(themes, false);

                // Update session tracking
                const lastPuzzle = gameState.sessionPuzzles[gameState.sessionPuzzles.length - 1];
                if (lastPuzzle && lastPuzzle.puzzleId === gameState.currentPuzzle.id) {
                    lastPuzzle.correct = false;
                    lastPuzzle.timeSpent = timeSpent;
                }

                // Check for coaching triggers
                checkCoachingTriggers(gameState.currentPuzzle, false, timeSpent);
            }

            updateAllDisplays();
            saveGameState();
        }

        function calculateRatingGain() {
            // Base rating gain varies by puzzle difficulty
            const puzzle = gameState.currentPuzzle;
            if (!puzzle) return 15;

            const diff = puzzle.rating - gameState.rating;

            // More rating for solving harder puzzles
            if (diff > 200) return 30;
            if (diff > 100) return 25;
            if (diff > 0) return 20;
            if (diff > -100) return 15;
            return 10;
        }

        function addXP(amount) {
            gameState.xp += amount;

            while (gameState.xp >= gameState.xpToLevel) {
                gameState.xp -= gameState.xpToLevel;
                gameState.level++;
                gameState.xpToLevel = Math.floor(gameState.xpToLevel * 1.5);

                // Level up rewards
                gameState.coins += 100 * gameState.level;
                gameState.powers.hint++;

                showLevelUp();
            }
        }

        // ==================== PUZZLE NAVIGATION ====================
        function navigatePuzzle(direction) {
            const newIndex = gameState.puzzleHistoryIndex + direction;

            if (newIndex < 0 || newIndex >= gameState.puzzleHistory.length) {
                return; // Out of bounds
            }

            gameState.puzzleHistoryIndex = newIndex;
            const historyEntry = gameState.puzzleHistory[newIndex];

            // Load puzzle from history
            gameState.currentPuzzle = historyEntry.puzzleData;
            gameState.hintUsed = historyEntry.hintUsed;

            // Reset board
            initPuzzle();
            renderBoard();
            updatePuzzleInfo();

            logger.trackAction('puzzle_navigation', { direction, index: newIndex });
        }

        function updateNavigationButtons() {
            const backBtn = document.getElementById('nav-back');
            const forwardBtn = document.getElementById('nav-forward');
            const positionEl = document.getElementById('puzzle-position');

            if (!backBtn || !forwardBtn || !positionEl) return; // Elements not ready

            // Enable/disable buttons
            backBtn.disabled = gameState.puzzleHistoryIndex <= 0;
            forwardBtn.disabled = gameState.puzzleHistoryIndex >= gameState.puzzleHistory.length - 1;

            // Update position text
            const current = gameState.puzzleHistoryIndex + 1;
            const total = gameState.puzzleHistory.length;
            positionEl.textContent = total > 0 ? `Puzzle ${current} of ${total}` : 'Puzzle 1';
        }

        function addToHistory(puzzle) {
            if (!puzzle) return;

            // When moving to a new puzzle, add to history
            const historyEntry = {
                puzzleData: { ...puzzle },
                hintUsed: gameState.hintUsed,
                timestamp: Date.now()
            };

            // If navigating back and then solving new puzzle, truncate future history
            if (gameState.puzzleHistoryIndex < gameState.puzzleHistory.length - 1) {
                gameState.puzzleHistory = gameState.puzzleHistory.slice(0, gameState.puzzleHistoryIndex + 1);
            }

            gameState.puzzleHistory.push(historyEntry);
            gameState.puzzleHistoryIndex = gameState.puzzleHistory.length - 1;

            updateNavigationButtons();
        }

        // ==================== PUZZLE LOADING ====================
        function loadNextPuzzle() {
            // Add current puzzle to history before loading next
            if (gameState.currentPuzzle) {
                addToHistory(gameState.currentPuzzle);
            }

            // Reset hint state for new puzzle
            gameState.hintUsed = false;

            if (gameState.inAssessment) {
                loadAssessmentPuzzle();
            } else if (gameState.inBootcamp) {
                loadBootcampPuzzle();
            } else {
                loadRatedPuzzle();
            }
        }

        function loadAssessmentPuzzle() {
            gameState.assessmentPuzzle++;

            // Progressive difficulty in assessment
            let pool;
            if (gameState.assessmentPuzzle <= 2) {
                pool = puzzleDatabase.beginner;
            } else if (gameState.assessmentPuzzle <= 4) {
                pool = puzzleDatabase.easy;
            } else if (gameState.assessmentPuzzle <= 6) {
                pool = puzzleDatabase.intermediate;
            } else if (gameState.assessmentPuzzle <= 8) {
                pool = puzzleDatabase.advanced;
            } else {
                pool = puzzleDatabase.expert;
            }

            const puzzle = pool[Math.floor(Math.random() * pool.length)];
            gameState.currentPuzzle = puzzle;
            gameState.puzzlesAttempted++;

            initializeChessInstance();
            renderBoard();
            updatePuzzleInfo();
            startTimer();
        }

        function loadRatedPuzzle() {
            // Select puzzle based on current rating
            let pool;
            const rating = gameState.rating;

            if (rating < 800) {
                pool = puzzleDatabase.beginner;
            } else if (rating < 1000) {
                pool = [...puzzleDatabase.beginner, ...puzzleDatabase.easy];
            } else if (rating < 1200) {
                pool = [...puzzleDatabase.easy, ...puzzleDatabase.intermediate];
            } else if (rating < 1400) {
                pool = [...puzzleDatabase.intermediate, ...puzzleDatabase.advanced];
            } else {
                pool = [...puzzleDatabase.advanced, ...puzzleDatabase.expert];
            }

            const puzzle = pool[Math.floor(Math.random() * pool.length)];
            gameState.currentPuzzle = puzzle;
            gameState.puzzlesAttempted++;

            initializeChessInstance();
            renderBoard();
            updatePuzzleInfo();
            startTimer();
        }

        // ==================== BOOTCAMP ADAPTIVE SYSTEM ====================
        // Phase 2: Theme Performance Tracking and Adaptive Puzzle Selection

        // Update theme stats after each puzzle
        function updateThemeStats(themes, wasCorrect) {
            if (!Array.isArray(themes) || themes.length === 0) return;

            const timeSpent = 30 - gameState.timer;

            themes.forEach(theme => {
                if (!gameState.themeStats[theme]) {
                    gameState.themeStats[theme] = {
                        correct: 0,
                        total: 0,
                        mastery: 0,
                        lastTested: Date.now(),
                        needsDrill: false,
                        attempts: []
                    };
                }

                const stats = gameState.themeStats[theme];
                stats.total++;
                if (wasCorrect) stats.correct++;
                stats.mastery = (stats.correct / stats.total) * 100;
                stats.lastTested = Date.now();
                stats.attempts.push({
                    correct: wasCorrect,
                    time: timeSpent,
                    timestamp: Date.now()
                });

                // Keep only last 100 attempts
                if (stats.attempts.length > 100) {
                    stats.attempts.shift();
                }

                // Mark as needing drill if below threshold
                if (bootcampCurriculum && bootcampCurriculum.adaptation_rules) {
                    const rules = bootcampCurriculum.adaptation_rules;
                    stats.needsDrill = stats.mastery < rules.acceptable_threshold &&
                                       stats.total >= rules.min_sample_size;
                }
            });

            logger.log('info', 'Theme stats updated', {
                themes,
                wasCorrect,
                mastery: getMasterySnapshot()
            });
        }

        // Get current mastery snapshot
        function getMasterySnapshot() {
            const snapshot = {};
            Object.keys(gameState.themeStats).forEach(theme => {
                snapshot[theme] = Math.round(gameState.themeStats[theme].mastery);
            });
            return snapshot;
        }

        // Identify weak themes needing focus
        function getWeakThemes() {
            if (!bootcampCurriculum || !bootcampCurriculum.adaptation_rules) {
                return [];
            }

            const rules = bootcampCurriculum.adaptation_rules;
            const weak = [];

            Object.entries(gameState.themeStats).forEach(([theme, stats]) => {
                if (stats.total >= rules.min_sample_size &&
                    stats.mastery < rules.acceptable_threshold) {
                    weak.push({
                        theme,
                        mastery: stats.mastery,
                        deficit: rules.acceptable_threshold - stats.mastery,
                        priority: (rules.acceptable_threshold - stats.mastery) * stats.total
                    });
                }
            });

            // Sort by priority (higher = more urgent)
            weak.sort((a, b) => b.priority - a.priority);
            return weak;
        }

        // Check if theme is mastered (can skip/reduce)
        function isThemeMastered(theme) {
            const stats = gameState.themeStats[theme];
            if (!stats || stats.total < 10) return false; // Need min sample

            if (!bootcampCurriculum || !bootcampCurriculum.adaptation_rules) {
                return stats.mastery >= 85;
            }

            const rules = bootcampCurriculum.adaptation_rules;
            return stats.mastery >= rules.mastery_threshold;
        }

        // Adaptive puzzle selector for bootcamp mode (70/20/10 algorithm)
        function loadBootcampPuzzle() {
            if (!bootcampCurriculum) {
                logger.log('error', 'Bootcamp curriculum not loaded');
                loadRatedPuzzle();
                return;
            }

            // 1. Determine which theme pool to use (based on day/rating)
            const dayData = bootcampCurriculum.daily_targets[gameState.bootcampDay - 1];
            const poolName = dayData.focus;
            const themePool = bootcampCurriculum.theme_pools[poolName];

            // 2. Get weak themes
            const weakThemes = getWeakThemes();

            // 3. Decide selection strategy (70/20/10 split)
            const roll = Math.random();
            let selectedTheme = null;

            if (roll < 0.70 && weakThemes.length > 0) {
                // 70% chance: Focus on weakness
                selectedTheme = weakThemes[0].theme;
                logger.log('info', 'Weakness focus', {
                    theme: selectedTheme,
                    mastery: weakThemes[0].mastery
                });

            } else if (roll < 0.90) {
                // 20% chance: Maintenance (practice all non-mastered themes from pool)
                const poolThemes = themePool.themes.filter(t => {
                    const stats = gameState.themeStats[t.id];
                    return !stats || !isThemeMastered(t.id);
                });
                if (poolThemes.length > 0) {
                    selectedTheme = poolThemes[Math.floor(Math.random() * poolThemes.length)].id;
                    logger.log('info', 'Maintenance', { theme: selectedTheme });
                }

            } else {
                // 10% chance: Introduce new theme
                const unseenThemes = themePool.themes.filter(t => !gameState.themeStats[t.id]);
                if (unseenThemes.length > 0) {
                    selectedTheme = unseenThemes[Math.floor(Math.random() * unseenThemes.length)].id;
                    logger.log('info', 'New theme', { theme: selectedTheme });
                }
            }

            // 4. Filter puzzles by theme and rating range
            const rating = gameState.rating;
            const ratingRange = themePool.rating_range;
            const minRating = Math.max(rating - 150, ratingRange[0]);
            const maxRating = Math.min(rating + 150, ratingRange[1]);

            let candidates = [];

            if (selectedTheme) {
                candidates = getAllPuzzlesWithTheme(selectedTheme, minRating, maxRating);
            }

            if (candidates.length === 0) {
                logger.log('warn', 'No puzzles found for theme, falling back to pool', {
                    theme: selectedTheme
                });
                // Fallback: any puzzle in rating range
                candidates = getAllPuzzlesInRange(minRating, maxRating);
            }

            if (candidates.length === 0) {
                logger.log('error', 'No puzzles available in range, using rated puzzle');
                loadRatedPuzzle();
                return;
            }

            // 5. Select random puzzle from candidates
            const puzzle = candidates[Math.floor(Math.random() * candidates.length)];
            gameState.currentPuzzle = puzzle;
            gameState.puzzlesAttempted++;
            gameState.bootcampPuzzlesToday++;

            // 6. Track session
            gameState.sessionPuzzles.push({
                puzzleId: puzzle.id,
                themes: puzzle.themes || [],
                rating: puzzle.rating,
                startTime: Date.now(),
                correct: null,
                timeSpent: null
            });

            initializeChessInstance();
            renderBoard();
            updatePuzzleInfo();
            startTimer();

            logger.log('info', 'Loaded bootcamp puzzle', {
                theme: selectedTheme,
                puzzleRating: puzzle.rating,
                playerRating: rating,
                candidates: candidates.length
            });
        }

        // Helper: Get all puzzles with specific theme
        function getAllPuzzlesWithTheme(theme, minRating, maxRating) {
            const allPuzzles = [];

            // Iterate through all tier databases
            Object.values(puzzleDatabase).forEach(tierPuzzles => {
                if (Array.isArray(tierPuzzles)) {
                    tierPuzzles.forEach(puzzle => {
                        if (puzzle.themes &&
                            puzzle.themes.includes(theme) &&
                            puzzle.rating >= minRating &&
                            puzzle.rating <= maxRating) {
                            allPuzzles.push(puzzle);
                        }
                    });
                }
            });

            return allPuzzles;
        }

        // Helper: Get all puzzles in rating range
        function getAllPuzzlesInRange(minRating, maxRating) {
            const allPuzzles = [];

            Object.values(puzzleDatabase).forEach(tierPuzzles => {
                if (Array.isArray(tierPuzzles)) {
                    tierPuzzles.forEach(puzzle => {
                        if (puzzle.rating >= minRating && puzzle.rating <= maxRating) {
                            allPuzzles.push(puzzle);
                        }
                    });
                }
            });

            return allPuzzles;
        }

        // ==================== AI-POWERED COACHING SYSTEM ====================
        // Phase 5: Real-Time Coaching with AI-Generated Messages

        // Coaching context for tracking when to trigger coaching
        let coachingContext = {
            recentFailures: [],  // Last 10 failures with themes
            currentStreak: 0,
            lastCoachTime: 0,
            coachingCooldown: 30000  // 30 seconds between coaching messages
        };

        // Check if coaching should trigger and display message
        function checkCoachingTriggers(puzzle, wasCorrect, timeSpent) {
            if (!gameState.inBootcamp) return;
            if (!puzzle) return;

            const now = Date.now();

            // Cooldown check - don't spam coaching
            if (now - coachingContext.lastCoachTime < coachingContext.coachingCooldown) {
                return;
            }

            const themes = puzzle.themes || [];
            const primaryTheme = themes[0] || 'general';

            if (wasCorrect) {
                coachingContext.currentStreak++;
                coachingContext.recentFailures = [];

                // Check for praise triggers
                if (coachingContext.currentStreak === 5) {
                    triggerCoaching({
                        theme: primaryTheme,
                        triggerType: 'praise',
                        fen: puzzle.fen,
                        solution: puzzle.solution,
                        timeSpent: timeSpent
                    });
                    return;
                }

                // Check for mastery celebration
                const stats = gameState.themeStats[primaryTheme];
                if (stats && stats.mastery >= 85 && stats.total >= 20) {
                    const previousMastery = stats.attempts.length >= 2 ?
                        ((stats.correct - 1) / (stats.total - 1) * 100) : 0;
                    const justMastered = previousMastery < 85;
                    if (justMastered) {
                        triggerCoaching({
                            theme: primaryTheme,
                            triggerType: 'mastered',
                            fen: puzzle.fen,
                            mastery: Math.round(stats.mastery),
                            timeSpent: timeSpent
                        });
                        return;
                    }
                }

            } else {
                // Failed
                coachingContext.currentStreak = 0;
                coachingContext.recentFailures.push({ theme: primaryTheme, time: now });

                // Keep only last 10
                if (coachingContext.recentFailures.length > 10) {
                    coachingContext.recentFailures.shift();
                }

                // Check for struggle patterns
                const recentThemeFailures = coachingContext.recentFailures.filter(f => f.theme === primaryTheme);

                if (recentThemeFailures.length >= 3) {
                    // 3+ failures on this theme recently
                    triggerCoaching({
                        theme: primaryTheme,
                        triggerType: 'struggle',
                        fen: puzzle.fen,
                        solution: puzzle.solution,
                        failureCount: recentThemeFailures.length,
                        timeSpent: timeSpent
                    });
                    coachingContext.recentFailures = [];  // Clear after coaching
                    return;
                }

                // Check for slow solve
                const avgTime = getAverageTime(primaryTheme);
                if (avgTime > 0 && timeSpent > avgTime * 2) {
                    triggerCoaching({
                        theme: primaryTheme,
                        triggerType: 'slow',
                        fen: puzzle.fen,
                        solution: puzzle.solution,
                        avgTime: Math.round(avgTime),
                        timeSpent: Math.round(timeSpent)
                    });
                    return;
                }
            }

            // Check for first encounter with new theme
            const stats = gameState.themeStats[primaryTheme];
            if (stats && stats.total === 1) {
                triggerCoaching({
                    theme: primaryTheme,
                    triggerType: 'intro',
                    fen: puzzle.fen,
                    solution: puzzle.solution,
                    timeSpent: timeSpent
                });
                return;
            }
        }

        // Get average time for a theme
        function getAverageTime(theme) {
            const stats = gameState.themeStats[theme];
            if (!stats || stats.attempts.length === 0) return 0;

            const totalTime = stats.attempts.reduce((sum, a) => sum + a.time, 0);
            return totalTime / stats.attempts.length;
        }

        // Trigger coaching with AI-generated message
        async function triggerCoaching(context) {
            logger.log('info', 'Coaching triggered', context);

            // Generate coaching message
            const message = await generateCoachingMessage(context);

            // Determine title based on trigger type
            const titles = {
                'struggle': 'ü§î Coaching Tip',
                'intro': 'üí° New Pattern',
                'mastered': 'üéâ Mastery Achieved!',
                'praise': 'üåü Great Work!',
                'slow': '‚è±Ô∏è Time Management'
            };

            const title = titles[context.triggerType] || 'ü§ñ Coach';

            showCoaching(message, title);
        }

        // AI-powered coaching message generation with Stockfish position analysis
        async function generateCoachingMessage(context) {
            // Analyze position with Stockfish for context-aware coaching
            const analysis = await aiEngine.analyzePosition(context.fen, 12);

            // Extract piece positions from FEN for position-specific references
            const positionInfo = extractPositionInfo(context.fen);

            // Enhance context with Stockfish analysis and position info
            const enhancedContext = {
                ...context,
                analysis: analysis,
                positionInfo: positionInfo
            };

            // Build prompt for LLM with position analysis
            const prompt = buildCoachingPrompt(enhancedContext);

            // Try to generate with AI, fallback to template if unavailable
            try {
                const aiMessage = await callCoachingAI(prompt);
                if (aiMessage) return aiMessage;
            } catch (error) {
                logger.log('warn', 'AI coaching failed, using fallback', { error: error.message });
            }

            // Fallback: Generate contextual message without AI API
            return generateFallbackMessage(enhancedContext);
        }

        // Extract key piece positions and features from FEN
        function extractPositionInfo(fen) {
            if (!fen) return { pieces: [], features: [] };

            const parts = fen.split(' ');
            const board = parts[0];
            const toMove = parts[1] === 'w' ? 'White' : 'Black';

            const pieces = [];
            const features = [];

            // Parse board ranks (8th rank to 1st rank)
            const ranks = board.split('/');

            for (let rankIdx = 0; rankIdx < ranks.length; rankIdx++) {
                const rank = ranks[rankIdx];
                let fileIdx = 0;

                for (let i = 0; i < rank.length; i++) {
                    const char = rank[i];

                    if (/[1-8]/.test(char)) {
                        // Skip empty squares
                        fileIdx += parseInt(char);
                    } else {
                        // Piece found
                        const file = String.fromCharCode(97 + fileIdx); // a-h
                        const rankNum = 8 - rankIdx; // 8-1
                        const square = file + rankNum;

                        const pieceTypes = {
                            'K': 'King', 'Q': 'Queen', 'R': 'Rook',
                            'B': 'Bishop', 'N': 'Knight', 'P': 'Pawn',
                            'k': 'king', 'q': 'queen', 'r': 'rook',
                            'b': 'bishop', 'n': 'knight', 'p': 'pawn'
                        };

                        const piece = {
                            type: pieceTypes[char] || char,
                            square: square,
                            color: char === char.toUpperCase() ? 'White' : 'Black'
                        };

                        pieces.push(piece);

                        // Note important pieces for potential reference
                        if (char.toLowerCase() === 'k' || char.toLowerCase() === 'q' || char.toLowerCase() === 'n') {
                            features.push(`${piece.color} ${piece.type} on ${square}`);
                        }

                        fileIdx++;
                    }
                }
            }

            return { pieces, features, toMove };
        }

        // Build prompt for AI coaching with Stockfish analysis
        function buildCoachingPrompt(context) {
            const { theme, triggerType, fen, solution, mastery, failureCount, avgTime, timeSpent, analysis, positionInfo } = context;

            // Build position description from Stockfish + FEN parsing
            let positionDesc = `Position FEN: ${fen}\n`;

            if (positionInfo && positionInfo.features && positionInfo.features.length > 0) {
                positionDesc += `Key pieces: ${positionInfo.features.slice(0, 5).join(', ')}\n`;
                positionDesc += `Turn to move: ${positionInfo.toMove}\n`;
            }

            if (analysis && analysis.bestMove) {
                const bestMoveReadable = aiEngine.convertMoveToReadable(analysis.bestMove);
                const scoreText = analysis.score ? ` (eval: ${analysis.score > 0 ? '+' : ''}${analysis.score.toFixed(1)})` : '';
                positionDesc += `Best move: ${bestMoveReadable}${scoreText}\n`;
            }

            let prompt = `You are a supportive chess coach. Generate a brief, encouraging coaching message that references the ACTUAL position.

${positionDesc}
Puzzle theme: ${theme}
Solution moves: ${solution ? solution.join(', ') : 'unknown'}

`;

            if (triggerType === 'struggle') {
                prompt += `The student has failed ${failureCount || 3} recent ${theme} puzzles.
Provide a brief, encouraging tip that references specific pieces and squares from THIS position.
Example: "Notice how the knight on f6 can reach e4 to fork the king and rook."
Be conversational and supportive, not robotic.
Maximum 2 sentences.`;

            } else if (triggerType === 'intro') {
                prompt += `This is the student's first ${theme} puzzle.
Provide a brief introduction to the ${theme} pattern using actual piece locations from THIS position.
Example: "In this position, your bishop on c4 can exploit the weakness on f7."
Maximum 2 sentences.`;

            } else if (triggerType === 'mastered') {
                prompt += `The student achieved ${mastery}% mastery on ${theme} puzzles!
Provide brief, genuine praise.
Maximum 1 sentence.`;

            } else if (triggerType === 'praise') {
                prompt += `The student just solved 5 puzzles in a row!
Provide brief, genuine praise.
Maximum 1 sentence.`;

            } else if (triggerType === 'slow') {
                prompt += `The student took ${timeSpent}s on this puzzle (average: ${avgTime}s).
Provide a brief tip about pattern recognition using THIS specific position.
Reference actual pieces to help them see the pattern faster next time.
Maximum 2 sentences.`;
            }

            prompt += `\n\nGenerate ONLY the coaching message text. No labels, no formatting. Reference actual squares and pieces.`;

            return prompt;
        }

        // Call AI API for coaching (OpenAI GPT-3.5-turbo)
        async function callCoachingAI(prompt) {
            // Check if API key is available (would need to be configured)
            const apiKey = localStorage.getItem('openai_api_key');

            if (!apiKey) {
                logger.log('info', 'No OpenAI API key configured, using fallback messages');
                return null;
            }

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-3.5-turbo',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a supportive chess coach who provides brief, encouraging guidance.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 100,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.statusText}`);
                }

                const data = await response.json();
                const message = data.choices[0]?.message?.content?.trim();

                logger.log('success', 'AI coaching message generated', { length: message?.length });

                return message;

            } catch (error) {
                logger.log('error', 'Failed to generate AI coaching', { error: error.message });
                return null;
            }
        }

        // Fallback message generation with position awareness (no AI API required)
        function generateFallbackMessage(context) {
            const { theme, triggerType, mastery, failureCount, avgTime, timeSpent, analysis, positionInfo } = context;

            // Try to add position-specific detail when available
            let positionHint = '';
            if (analysis && analysis.bestMove) {
                const moveReadable = aiEngine.convertMoveToReadable(analysis.bestMove);
                positionHint = ` The key move starts with ${moveReadable}.`;
            } else if (positionInfo && positionInfo.features && positionInfo.features.length > 0) {
                const firstFeature = positionInfo.features[0];
                positionHint = ` Notice the ${firstFeature}.`;
            }

            const messages = {
                'struggle': [
                    `Take your time with ${theme} puzzles - look for the key pieces and their relationships.${positionHint}`,
                    `${theme} patterns can be tricky! Focus on identifying the vulnerable pieces first.${positionHint}`,
                    `Remember: in ${theme} tactics, timing and piece coordination are crucial.${positionHint}`
                ],
                'intro': [
                    `Welcome to ${theme} puzzles! This tactical pattern is all about exploiting piece positioning.${positionHint}`,
                    `This is your first ${theme} puzzle - look for how the pieces interact to create the tactic.${positionHint}`,
                    `${theme} is a fundamental pattern - take your time to understand it here.${positionHint}`
                ],
                'mastered': [
                    `Incredible! You've mastered ${theme} with ${mastery}% accuracy!`,
                    `Outstanding work! ${mastery}% mastery of ${theme} puzzles - you've got this pattern down!`,
                    `Amazing progress! ${theme} is now one of your strengths at ${mastery}%!`
                ],
                'praise': [
                    `Five in a row - you're on fire! Keep this momentum going!`,
                    `Excellent streak! Your pattern recognition is really sharp right now.`,
                    `Outstanding! Five straight successes shows you're in the zone.`
                ],
                'slow': [
                    `You spent ${timeSpent}s on this one (average: ${avgTime}s). Try to spot ${theme} patterns more quickly!${positionHint}`,
                    `Pattern recognition speeds up with practice. Look for ${theme} setups faster!${positionHint}`,
                    `The more ${theme} puzzles you solve, the faster you'll recognize them!${positionHint}`
                ]
            };

            const messageList = messages[triggerType] || messages['praise'];
            const randomMessage = messageList[Math.floor(Math.random() * messageList.length)];

            return randomMessage;
        }

        // Display coaching toast
        function showCoaching(message, title) {
            if (!message) return;

            const toast = document.getElementById('coaching-toast');
            const titleEl = document.getElementById('coach-title');
            const textEl = document.getElementById('coach-text');

            titleEl.textContent = title || 'ü§ñ Coach';
            textEl.textContent = message;

            toast.style.display = 'flex';

            // Auto-hide after 8 seconds
            setTimeout(() => {
                toast.style.display = 'none';
            }, 8000);

            coachingContext.lastCoachTime = Date.now();

            logger.log('info', 'Coaching displayed', { title, messageLength: message.length });
        }

        // Close coaching toast
        function closeCoach() {
            document.getElementById('coaching-toast').style.display = 'none';
        }

        // ==================== PROFILE MANAGEMENT SYSTEM ====================
        // Supports multiple user profiles with safe deletion and recovery

        let currentProfileId = null;
        const PROFILE_STORAGE_KEY = 'chessBlitzProfiles';
        const ACTIVE_PROFILE_KEY = 'chessBlitzActiveProfile';

        // Load all profiles from localStorage
        function loadAllProfiles() {
            const stored = localStorage.getItem(PROFILE_STORAGE_KEY);
            return stored ? JSON.parse(stored) : {
                profiles: {},
                archived: {}
            };
        }

        // Save all profiles to localStorage
        function saveAllProfiles(data) {
            localStorage.setItem(PROFILE_STORAGE_KEY, JSON.stringify(data));
        }

        // Initialize profile system on app start
        function initializeProfiles() {
            const allProfiles = loadAllProfiles();

            // Check if there are any profiles
            const profileIds = Object.keys(allProfiles.profiles);

            if (profileIds.length === 0) {
                // No profiles exist - create default profile
                createNewProfile('Player 1', true);
            } else {
                // Load the active profile or first available
                const activeId = localStorage.getItem(ACTIVE_PROFILE_KEY);
                if (activeId && allProfiles.profiles[activeId]) {
                    loadProfile(activeId);
                } else {
                    loadProfile(profileIds[0]);
                }
            }

            refreshProfileDropdown();
        }

        // Create a new profile
        function createNewProfile(name = null, skipPrompt = false) {
            if (!name && !skipPrompt) {
                name = document.getElementById('new-profile-name').value.trim();
            }

            if (!name) {
                alert('Please enter a profile name');
                return;
            }

            const allProfiles = loadAllProfiles();
            const profileId = 'profile_' + Date.now();

            // Create new profile with fresh game state
            allProfiles.profiles[profileId] = {
                id: profileId,
                name: name,
                createdDate: new Date().toISOString(),
                lastPlayed: new Date().toISOString(),
                gameState: getDefaultGameState()
            };

            saveAllProfiles(allProfiles);
            loadProfile(profileId);
            refreshProfileDropdown();
            refreshProfileManagementUI();

            if (!skipPrompt) {
                document.getElementById('new-profile-name').value = '';
            }

            logger.log('success', 'Profile created', { name, id: profileId });
        }

        // Get default game state for new profiles
        function getDefaultGameState() {
            return {
                coins: 500,
                rating: 800,
                level: 1,
                xp: 0,
                xpToNextLevel: 100,
                puzzlesAttempted: 0,
                puzzlesSolved: 0,
                currentStreak: 0,
                bestStreak: 0,
                hintsUsed: 0,
                totalTime: 0,
                averageTime: 0,
                mode: null,
                inBootcamp: false,
                bootcampDay: 0,
                themeStats: {},
                sessionPuzzles: [],
                dailyStats: {}
            };
        }

        // Load a profile and set it as active
        function loadProfile(profileId) {
            const allProfiles = loadAllProfiles();
            const profile = allProfiles.profiles[profileId];

            if (!profile) {
                logger.log('error', 'Profile not found', { profileId });
                return;
            }

            currentProfileId = profileId;
            localStorage.setItem(ACTIVE_PROFILE_KEY, profileId);

            // Load the profile's game state into the global gameState
            Object.assign(gameState, profile.gameState);

            // Update last played timestamp
            profile.lastPlayed = new Date().toISOString();
            allProfiles.profiles[profileId] = profile;
            saveAllProfiles(allProfiles);

            // Refresh UI
            updateUI();
            refreshProfileDropdown();

            logger.log('success', 'Profile loaded', { name: profile.name, id: profileId });
        }

        // Switch profile from dropdown
        function switchProfile(profileId) {
            if (profileId === currentProfileId) return;

            // Save current profile's game state before switching
            if (currentProfileId) {
                saveCurrentProfile();
            }

            loadProfile(profileId);
        }

        // Save current profile's game state
        function saveCurrentProfile() {
            if (!currentProfileId) return;

            const allProfiles = loadAllProfiles();
            const profile = allProfiles.profiles[currentProfileId];

            if (profile) {
                profile.gameState = { ...gameState };
                profile.lastPlayed = new Date().toISOString();
                allProfiles.profiles[currentProfileId] = profile;
                saveAllProfiles(allProfiles);
            }
        }

        // Archive a profile (soft delete - recoverable)
        function archiveProfile(profileId) {
            if (profileId === currentProfileId) {
                alert('Cannot archive the currently active profile. Please switch to another profile first.');
                return;
            }

            // Double confirmation for safety
            const allProfiles = loadAllProfiles();
            const profile = allProfiles.profiles[profileId];

            if (!profile) return;

            const confirmed = confirm(
                `‚ö†Ô∏è ARCHIVE PROFILE "${profile.name}"?\n\n` +
                `This will move the profile to archived (recoverable).\n\n` +
                `The profile can be restored later from the Archived Profiles section.\n\n` +
                `Continue?`
            );

            if (!confirmed) return;

            // Move to archived
            allProfiles.archived[profileId] = {
                ...profile,
                archivedDate: new Date().toISOString()
            };
            delete allProfiles.profiles[profileId];

            saveAllProfiles(allProfiles);
            refreshProfileManagementUI();

            logger.log('info', 'Profile archived', { name: profile.name, id: profileId });
        }

        // Restore an archived profile
        function restoreProfile(profileId) {
            const allProfiles = loadAllProfiles();
            const profile = allProfiles.archived[profileId];

            if (!profile) return;

            // Remove archived metadata and restore
            delete profile.archivedDate;
            allProfiles.profiles[profileId] = profile;
            delete allProfiles.archived[profileId];

            saveAllProfiles(allProfiles);
            refreshProfileDropdown();
            refreshProfileManagementUI();

            logger.log('success', 'Profile restored', { name: profile.name, id: profileId });
        }

        // PERMANENT delete (requires triple confirmation)
        function permanentlyDeleteProfile(profileId) {
            const allProfiles = loadAllProfiles();
            const profile = allProfiles.archived[profileId];

            if (!profile) return;

            const step1 = confirm(
                `üö® PERMANENT DELETE WARNING\n\n` +
                `You are about to PERMANENTLY DELETE the profile "${profile.name}".\n\n` +
                `This action CANNOT be undone.\n\n` +
                `Are you sure you want to continue?`
            );

            if (!step1) return;

            const step2 = confirm(
                `‚ö†Ô∏è SECOND CONFIRMATION\n\n` +
                `Profile: "${profile.name}"\n` +
                `Rating: ${profile.gameState.rating}\n` +
                `Puzzles Solved: ${profile.gameState.puzzlesSolved}\n\n` +
                `This data will be PERMANENTLY LOST.\n\n` +
                `Continue with deletion?`
            );

            if (!step2) return;

            const step3 = prompt(
                `FINAL CONFIRMATION\n\n` +
                `Type the profile name "${profile.name}" exactly to confirm permanent deletion:`
            );

            if (step3 !== profile.name) {
                alert('Name did not match. Deletion cancelled.');
                return;
            }

            // Permanently delete
            delete allProfiles.archived[profileId];
            saveAllProfiles(allProfiles);
            refreshProfileManagementUI();

            logger.log('warn', 'Profile permanently deleted', { name: profile.name, id: profileId });
            alert(`Profile "${profile.name}" has been permanently deleted.`);
        }

        // Export all profiles to JSON file
        function exportAllProfiles() {
            const allProfiles = loadAllProfiles();
            const exportData = {
                ...allProfiles,
                exportDate: new Date().toISOString(),
                version: '1.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ChessBlitz_Profiles_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            logger.log('success', 'Profiles exported', { count: Object.keys(allProfiles.profiles).length });
        }

        // Import profiles from JSON file
        function importProfiles(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);

                    if (!imported.profiles) {
                        throw new Error('Invalid profile export file');
                    }

                    const confirmed = confirm(
                        `Import ${Object.keys(imported.profiles).length} profiles?\n\n` +
                        `This will NOT delete your existing profiles.\n` +
                        `Duplicate profile IDs will be skipped.`
                    );

                    if (!confirmed) return;

                    const allProfiles = loadAllProfiles();
                    let importedCount = 0;

                    // Import profiles (skip duplicates)
                    for (const [id, profile] of Object.entries(imported.profiles)) {
                        if (!allProfiles.profiles[id]) {
                            allProfiles.profiles[id] = profile;
                            importedCount++;
                        }
                    }

                    // Import archived profiles
                    for (const [id, profile] of Object.entries(imported.archived || {})) {
                        if (!allProfiles.archived[id]) {
                            allProfiles.archived[id] = profile;
                        }
                    }

                    saveAllProfiles(allProfiles);
                    refreshProfileDropdown();
                    refreshProfileManagementUI();

                    logger.log('success', 'Profiles imported', { count: importedCount });
                    alert(`Successfully imported ${importedCount} profiles!`);

                } catch (error) {
                    logger.log('error', 'Failed to import profiles', { error: error.message });
                    alert('Failed to import profiles. Please check the file format.');
                }
            };
            reader.readAsText(file);
        }

        // Refresh the profile dropdown in the header
        function refreshProfileDropdown() {
            const dropdown = document.getElementById('profile-dropdown');
            const allProfiles = loadAllProfiles();

            dropdown.innerHTML = '';

            // Add all active profiles
            for (const [id, profile] of Object.entries(allProfiles.profiles)) {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = profile.name;
                if (id === currentProfileId) {
                    option.selected = true;
                }
                dropdown.appendChild(option);
            }
        }

        // Show profile management modal
        function showProfileManagement() {
            document.getElementById('profile-modal').style.display = 'flex';
            refreshProfileManagementUI();
        }

        // Close profile management modal
        function closeProfileManagement() {
            document.getElementById('profile-modal').style.display = 'none';
        }

        // Refresh the profile management UI lists
        function refreshProfileManagementUI() {
            const allProfiles = loadAllProfiles();

            // Active profiles list
            const profileList = document.getElementById('profile-list');
            profileList.innerHTML = '';

            if (Object.keys(allProfiles.profiles).length === 0) {
                profileList.innerHTML = '<p style="color: var(--light); opacity: 0.5;">No profiles yet. Create one above!</p>';
            } else {
                for (const [id, profile] of Object.entries(allProfiles.profiles)) {
                    const isActive = id === currentProfileId;
                    const item = document.createElement('div');
                    item.className = `profile-item ${isActive ? 'active' : ''}`;
                    item.innerHTML = `
                        <div class="profile-info">
                            <div class="profile-name">${profile.name} ${isActive ? '‚≠ê' : ''}</div>
                            <div class="profile-meta">
                                Rating: ${profile.gameState.rating} |
                                Puzzles: ${profile.gameState.puzzlesSolved}/${profile.gameState.puzzlesAttempted} |
                                Created: ${new Date(profile.createdDate).toLocaleDateString()}
                            </div>
                        </div>
                        <div class="profile-actions">
                            ${!isActive ? `<button onclick="switchProfile('${id}')">Switch</button>` : ''}
                            ${!isActive ? `<button class="danger" onclick="archiveProfile('${id}')">Archive</button>` : ''}
                        </div>
                    `;
                    profileList.appendChild(item);
                }
            }

            // Archived profiles list
            const archivedList = document.getElementById('archived-profile-list');
            archivedList.innerHTML = '';

            if (Object.keys(allProfiles.archived).length === 0) {
                archivedList.innerHTML = '<p style="color: var(--light); opacity: 0.5;">No archived profiles</p>';
            } else {
                for (const [id, profile] of Object.entries(allProfiles.archived)) {
                    const item = document.createElement('div');
                    item.className = 'profile-item archived';
                    item.innerHTML = `
                        <div class="profile-info">
                            <div class="profile-name">${profile.name} (Archived)</div>
                            <div class="profile-meta">
                                Rating: ${profile.gameState.rating} |
                                Archived: ${new Date(profile.archivedDate).toLocaleDateString()}
                            </div>
                        </div>
                        <div class="profile-actions">
                            <button onclick="restoreProfile('${id}')">Restore</button>
                            <button class="danger" onclick="permanentlyDeleteProfile('${id}')">Permanently Delete</button>
                        </div>
                    `;
                    archivedList.appendChild(item);
                }
            }
        }

        // Override existing saveGameState to also save to current profile
        const originalSaveGameState = saveGameState;
        function saveGameState() {
            originalSaveGameState(); // Call the original function
            saveCurrentProfile(); // Also save to profile system
        }

        // Initialize Chess.js instance for current puzzle
        function initializeChessInstance() {
            if (typeof Chess !== 'undefined' && gameState.currentPuzzle) {
                gameState.chessInstance = new Chess(gameState.currentPuzzle.fen);
                logger.log('info', 'Chess instance initialized', { fen: gameState.currentPuzzle.fen });
            } else {
                logger.log('error', 'Chess.js not available or no puzzle loaded');
            }
        }

        // Get legal moves for a piece at a given position
        function getLegalMoves(row, col) {
            if (!gameState.chessInstance) return [];

            const square = squareToAlgebraic(row, col);
            const moves = gameState.chessInstance.moves({ square: square, verbose: true });

            return moves.map(move => ({
                from: move.from,
                to: move.to,
                toRow: 8 - parseInt(move.to[1]),
                toCol: move.to.charCodeAt(0) - 'a'.charCodeAt(0)
            }));
        }

        // ==================== TIMER ====================
        function startTimer() {
            gameState.timer = 30;
            updateTimerDisplay();

            gameState.timerInterval = setInterval(() => {
                if (gameState.timerFrozen) return;

                gameState.timer--;
                updateTimerDisplay();

                if (gameState.timer <= 0) {
                    clearInterval(gameState.timerInterval);
                    handleWrongAnswer();
                    setTimeout(() => loadNextPuzzle(), 1500);
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const timerElement = document.getElementById('timer');
            timerElement.textContent = gameState.timer;

            if (gameState.timer <= 10) {
                timerElement.classList.add('warning');
            } else {
                timerElement.classList.remove('warning');
            }
        }

        // ==================== POWER-UPS ====================
        function usePower(type) {
            if (gameState.powers[type] <= 0) return;
            if (!gameState.currentPuzzle) return;

            gameState.powers[type]--;
            logger.trackAction('power_used', { type, remaining: gameState.powers[type] });

            switch (type) {
                case 'hint':
                    showHint();
                    break;
                case 'freeze':
                    freezeTimer();
                    break;
                case 'skip':
                    skipPuzzle();
                    break;
                case 'double':
                    activateDoubleXP();
                    break;
            }

            updatePowerDisplays();
            saveGameState();
        }

        async function showHint() {
            const puzzle = gameState.currentPuzzle;
            const hint = puzzle.hint;
            const instructionEl = document.getElementById('puzzle-instruction');

            // Reveal puzzle title when hint used (blind solving)
            gameState.hintUsed = true;
            document.getElementById('puzzle-title').textContent = puzzle.title;

            // Show puzzle hint immediately
            instructionEl.innerHTML = `<span class="highlight">üí° ${puzzle.title}:</span> ${hint}`;

            // Highlight the target square
            const solution = puzzle.solution[0];
            const toCol = solution.charCodeAt(2) - 97;
            const toRow = 8 - parseInt(solution[3]);

            const squares = document.querySelectorAll('.square');
            const targetSquare = squares[toRow * 8 + toCol];
            targetSquare.classList.add('hint');

            setTimeout(() => targetSquare.classList.remove('hint'), 3000);

            // Get AI analysis
            instructionEl.innerHTML += `<br><span style="color: var(--secondary);">ü§ñ AI analyzing...</span>`;

            const analysis = await aiEngine.analyzePosition(puzzle.fen);

            if (analysis) {
                const moveReadable = aiEngine.convertMoveToReadable(analysis.bestMove);
                const scoreText = analysis.score ? ` (${analysis.score > 0 ? '+' : ''}${analysis.score.toFixed(1)})` : '';
                instructionEl.innerHTML = `<span class="highlight">üí° ${puzzle.title}:</span> ${hint}<br><span style="color: var(--secondary);">ü§ñ AI suggests: ${moveReadable}${scoreText}</span>`;
                logger.trackAction('ai_hint_used', { move: analysis.bestMove, score: analysis.score });
            } else {
                instructionEl.innerHTML = `<span class="highlight">üí° ${puzzle.title}:</span> ${hint}<br><span style="color: var(--fire);">ü§ñ AI unavailable</span>`;
            }
        }

        function freezeTimer() {
            gameState.timerFrozen = true;
            document.getElementById('timer').style.color = '#00cec9';

            setTimeout(() => {
                gameState.timerFrozen = false;
                document.getElementById('timer').style.color = '';
            }, 10000);
        }

        function skipPuzzle() {
            clearInterval(gameState.timerInterval);
            loadNextPuzzle();
        }

        function activateDoubleXP() {
            gameState.doubleXpActive = true;
            // Visual indicator
            document.getElementById('power-double').style.boxShadow = '0 0 20px var(--gold)';
        }

        // ==================== THEMES ====================
        function selectTheme(theme) {
            if (!gameState.unlockedThemes.includes(theme)) return;

            gameState.currentTheme = theme;

            const boardContainer = document.getElementById('board-container');
            boardContainer.className = 'board-container';
            if (theme !== 'classic') {
                boardContainer.classList.add('theme-' + theme);
            }

            // Update glove selection
            document.querySelectorAll('.glove-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.theme === theme) {
                    item.classList.add('active');
                }
            });

            saveGameState();
        }

        // ==================== DISPLAY UPDATES ====================
        function updateAllDisplays() {
            // Header stats
            document.getElementById('coins-display').textContent = gameState.coins.toLocaleString();
            document.getElementById('rating-display').textContent = gameState.rating;
            document.getElementById('level-badge').textContent = gameState.level;
            document.getElementById('xp-current').textContent = gameState.xp;
            document.getElementById('xp-needed').textContent = gameState.xpToLevel;
            document.getElementById('xp-bar').style.width = (gameState.xp / gameState.xpToLevel * 100) + '%';

            // Streak
            document.getElementById('streak-count').textContent = gameState.streak;
            const streakBonus = gameState.streak >= 3 ? Math.floor((gameState.streak - 2) * 10) : 0;
            document.getElementById('streak-bonus').textContent = '+' + streakBonus + '% XP';

            const streakContainer = document.getElementById('streak-container');
            if (gameState.streak >= 3) {
                streakContainer.classList.add('on-fire');
            } else {
                streakContainer.classList.remove('on-fire');
            }

            // Session stats
            document.getElementById('puzzles-solved').textContent = gameState.puzzlesSolved;
            document.getElementById('accuracy').textContent = gameState.puzzlesAttempted > 0
                ? Math.round(gameState.puzzlesSolved / gameState.puzzlesAttempted * 100) + '%'
                : '0%';
            document.getElementById('best-streak').textContent = gameState.bestStreak;
            document.getElementById('rating-gained').textContent = (gameState.ratingGained >= 0 ? '+' : '') + gameState.ratingGained;

            // Rank
            updateRankDisplay();

            // Powers
            updatePowerDisplays();
        }

        function updatePowerDisplays() {
            document.getElementById('hint-count').textContent = gameState.powers.hint;
            document.getElementById('freeze-count').textContent = gameState.powers.freeze;
            document.getElementById('skip-count').textContent = gameState.powers.skip;
            document.getElementById('double-count').textContent = gameState.powers.double;

            // Disable buttons if no uses left
            document.getElementById('power-hint').disabled = gameState.powers.hint <= 0;
            document.getElementById('power-freeze').disabled = gameState.powers.freeze <= 0;
            document.getElementById('power-skip').disabled = gameState.powers.skip <= 0;
            document.getElementById('power-double').disabled = gameState.powers.double <= 0;
        }

        function updateRankDisplay() {
            const rank = getCurrentRank();
            const nextRank = getNextRank();

            document.getElementById('rank-icon').textContent = rank.icon;
            document.getElementById('rank-name').textContent = rank.name;
            document.getElementById('rank-rating-text').textContent = 'Rating: ' + gameState.rating;
            document.getElementById('current-rank-label').textContent = rank.name;

            if (nextRank) {
                document.getElementById('next-rank-label').textContent = nextRank.name;
                const progress = (gameState.rating - rank.minRating) / (nextRank.minRating - rank.minRating) * 100;
                document.getElementById('rank-progress').style.width = Math.min(100, progress) + '%';
            } else {
                document.getElementById('next-rank-label').textContent = 'MAX';
                document.getElementById('rank-progress').style.width = '100%';
            }
        }

        function getCurrentRank() {
            for (let i = ranks.length - 1; i >= 0; i--) {
                if (gameState.rating >= ranks[i].minRating) {
                    return ranks[i];
                }
            }
            return ranks[0];
        }

        function getNextRank() {
            for (let i = 0; i < ranks.length; i++) {
                if (gameState.rating < ranks[i].minRating) {
                    return ranks[i];
                }
            }
            return null;
        }

        function updatePuzzleInfo() {
            const puzzle = gameState.currentPuzzle;
            if (!puzzle) return;

            // Validate toMove matches FEN position
            const chess = new Chess(puzzle.fen);
            const actualTurn = chess.turn() === 'w' ? 'White' : 'Black';
            if (puzzle.toMove !== actualTurn) {
                logger.log('warn', `Puzzle "${puzzle.title}" has incorrect toMove field`, {
                    expected: actualTurn,
                    actual: puzzle.toMove,
                    fen: puzzle.fen
                });
                puzzle.toMove = actualTurn; // Auto-correct
            }

            // BLIND SOLVING: Hide title until hint used
            if (!gameState.hintUsed) {
                document.getElementById('puzzle-title').textContent = 'Find the Best Move!';
            } else {
                document.getElementById('puzzle-title').textContent = puzzle.title;
            }

            document.getElementById('to-move').textContent = puzzle.toMove;
            document.getElementById('puzzle-instruction').innerHTML =
                `<span class="highlight">${puzzle.toMove}</span> to move. Find the winning tactic!`;

            // Update navigation buttons
            updateNavigationButtons();
        }

        function updateDailyProgress() {
            for (let i = 1; i <= 5; i++) {
                const dot = document.getElementById('daily-' + i);
                if (i <= gameState.dailyCompleted) {
                    dot.classList.add('complete');
                    dot.textContent = '‚úì';
                }
            }

            if (gameState.dailyCompleted >= 5) {
                // Give daily reward
                gameState.coins += 500;
                spawnConfetti();
            }
        }

        // Show feedback message (toast notification)
        function showFeedback(message, type = 'info') {
            // Remove any existing feedback
            const existing = document.querySelector('.feedback-toast');
            if (existing) existing.remove();

            // Create toast element
            const toast = document.createElement('div');
            toast.className = `feedback-toast ${type}`;
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#4dabf7'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-weight: bold;
                z-index: 10000;
                animation: slideDown 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;

            document.body.appendChild(toast);

            // Remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ==================== ASSESSMENT ====================
        function showWelcomeModal() {
            document.getElementById('welcome-modal').classList.add('active');
        }

        function startAssessment() {
            document.getElementById('welcome-modal').classList.remove('active');
            gameState.inAssessment = true;
            gameState.assessmentPuzzle = 0;
            gameState.assessmentScore = 0;
            gameState.assessmentResults = [];
            loadNextPuzzle();
        }

        function updateAssessmentProgress() {
            const dots = document.querySelectorAll('#assessment-progress .assessment-dot');

            gameState.assessmentResults.forEach((result, index) => {
                dots[index].classList.remove('current');
                dots[index].classList.add(result ? 'correct' : 'wrong');
                dots[index].textContent = result ? '‚úì' : '‚úó';
            });

            if (gameState.assessmentPuzzle < 10) {
                dots[gameState.assessmentPuzzle].classList.add('current');
            }
        }

        function completeAssessment() {
            clearInterval(gameState.timerInterval);
            gameState.inAssessment = false;

            // Calculate final rating based on performance
            const baseRating = 800;
            const scoreBonus = gameState.assessmentScore * 80; // Up to +800 for perfect
            const finalRating = baseRating + scoreBonus - (10 - gameState.assessmentScore) * 30;

            gameState.rating = Math.max(600, Math.min(2000, finalRating));
            gameState.coins += gameState.assessmentScore * 50;

            // Show completion modal
            document.getElementById('final-rating').textContent = gameState.rating;
            document.getElementById('final-rank').textContent = getCurrentRank().name;
            document.getElementById('assessment-score').textContent = gameState.assessmentScore;
            document.getElementById('assessment-coins').textContent = gameState.assessmentScore * 50;

            document.getElementById('assessment-complete-modal').classList.add('active');
            spawnConfetti();

            saveGameState();
        }

        function startTraining() {
            document.getElementById('assessment-complete-modal').classList.remove('active');
            updateAllDisplays();
            loadNextPuzzle();
        }

        // ==================== VISUAL EFFECTS ====================
        function showXPPopup(amount) {
            const popup = document.createElement('div');
            popup.className = 'xp-popup';
            popup.textContent = '+' + amount + ' XP';
            popup.style.left = (Math.random() * 60 + 20) + '%';
            popup.style.top = '40%';
            document.body.appendChild(popup);

            setTimeout(() => popup.remove(), 1500);
        }

        function showRatingChange(amount) {
            const popup = document.createElement('div');
            popup.className = 'rating-change ' + (amount >= 0 ? 'positive' : 'negative');
            popup.textContent = (amount >= 0 ? '+' : '') + amount + ' Rating';
            document.body.appendChild(popup);

            setTimeout(() => popup.remove(), 1500);
        }

        function showLevelUp() {
            const overlay = document.getElementById('level-up-overlay');
            document.getElementById('new-level').textContent = gameState.level;
            overlay.classList.add('active');
            spawnConfetti();

            setTimeout(() => overlay.classList.remove('active'), 2000);
        }

        function spawnConfetti() {
            const container = document.getElementById('confetti-container');
            const colors = ['#6c5ce7', '#00cec9', '#fd79a8', '#fdcb6e', '#e17055', '#00b894'];

            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                confetti.style.width = (5 + Math.random() * 10) + 'px';
                confetti.style.height = confetti.style.width;
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                container.appendChild(confetti);

                setTimeout(() => confetti.remove(), 3000);
            }
        }

        // ==================== ACHIEVEMENTS ====================
        function checkAchievements() {
            const achievementElements = document.querySelectorAll('.achievement');

            achievements.forEach((achievement, index) => {
                if (achievement.condition(gameState)) {
                    const element = achievementElements[index];
                    if (element.classList.contains('locked')) {
                        element.classList.remove('locked');
                        element.classList.add('unlocked');
                        // Could show achievement unlock popup here
                    }
                }
            });
        }

        // ==================== SHOP ====================
        function openShop() {
            alert('üõí Shop coming soon!\n\nSpend your coins on:\n‚Ä¢ More power-ups\n‚Ä¢ New board themes\n‚Ä¢ Special effects');
        }

        // ==================== INITIALIZE ====================
        init();
    </script>
</body>
</html>
